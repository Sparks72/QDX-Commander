<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QRP-Labs QDX Commander with Digital Audio by DJ0CU/G4ADF</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
	
	<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            overflow-x: hidden;
            min-height: 100vh;
            user-select: none;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
        }

       .main-panel {
    display: grid;
    grid-template-columns: 1fr 400px 1fr;
    gap: 20px;
}

        .left-panel, .right-panel, .center-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .panel h3 {
            cursor: grab;
        }

        .panel h3:active {
            cursor: grabbing;
        }

        .sortable-ghost {
            opacity: 0.4;
            background: #ff6b35;
        }

        .sortable-drag {
            opacity: 0.9;
            transform: rotate(2deg);
        }

        .frequency-display.lcd-panel {
            background: #000;
            border-radius: 10px;
            padding: 15px 20px;
            text-align: left;
            border: 2px solid #ff6b35;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .lcd-row {
            font-family: 'Courier New', monospace;
            font-size: 1.8em;
            color: #ff6b35;
            text-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
            letter-spacing: 0.05em;
            white-space: pre;
            line-height: 1.2;
        }

        .tuning-knob-container {
            width: 250px;
            height: 250px;
            position: relative;
            margin: 20px auto;
            display: flex !important;
            justify-content: center;
            align-items: center;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .tuning-knob-container:active {
            cursor: grabbing;
        }

        .tuning-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 2px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.15) 0deg, rgba(0, 0, 0, 0.1) 5deg, rgba(255, 255, 255, 0.15) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 2%, #c0c0c0 4%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 30% 30%, 100% 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tuning-knob::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e5e5, #c0c0c0);
            background-image:
                repeating-radial-gradient(circle at 50% 50%, transparent 0%, transparent 15%, rgba(0, 0, 0, 0.05) 15.5%, transparent 16%);
            z-index: 1;
        }

        .tuning-knob::after {
            content: "";
            position: absolute;
            width: 8px !important;
            height: 100px;
            background-color: #333 !important;
            border-radius: 8px;
            top: 10px;
            z-index: 3;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .tuning-knob-center {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tuning-knob:hover::after {
            background-color: #ff6b35 !important;
        }

        .frequency-markings {
            position: absolute;
            width: 280px;
            height: 280px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 0;
        }

        .frequency-mark {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            transform-origin: center;
        }

        .frequency-mark.major {
            width: 3px;
            height: 20px;
            background: rgba(255, 107, 53, 0.8);
        }

        .frequency-mark.minor {
            width: 1px;
            height: 10px;
            background: rgba(255, 255, 255, 0.4);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9em;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

       .btn-secondary:active {
    transform: translateY(0);
}

.btn-danger {
    background: linear-gradient(45deg, #ff4757, #ff3838);
    color: #fff;
}

.btn-danger:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 71, 87, 0.4);
}

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .mode-btn {
            padding: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .mode-btn.active {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
            border-color: #ff6b35;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        select {
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        select:disabled {
            background: rgba(100, 100, 100, 0.2);
            color: #888;
            border-color: rgba(100, 100, 100, 0.3);
            cursor: not-allowed;
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

      
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-text {
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .status-text.connected {
            color: #ff6b35;
            text-shadow: 0 0 8px rgba(255, 107, 53, 0.6);
            text-transform: uppercase;
        }

        .status-text.disconnected {
            color: #ff4757;
            text-shadow: 0 0 8px rgba(255, 71, 87, 0.6);
            text-transform: uppercase;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4757;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #ff6b35;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .memory-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .memory-btn {
            padding: 8px 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 45px;
            position: relative;
        }

        .memory-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .memory-btn.memory-occupied {
            background: rgba(255, 107, 53, 0.2);
            border-color: rgba(255, 107, 53, 0.5);
            color: #ff6b35;
        }

        .memory-btn.memory-selected {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
            border-color: #ff6b35;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .memory-btn.memory-occupied:hover {
            background: rgba(255, 107, 53, 0.3);
        }

        .memory-btn.memory-store-warning {
            background: rgba(255, 71, 87, 0.2);
            border-color: rgba(255, 71, 87, 0.5);
        }

        .memory-btn.memory-store-warning:hover {
            background: rgba(255, 71, 87, 0.3);
        }

        .memory-edit-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a2e;
            border: 2px solid #ff6b35;
            border-radius: 15px;
            padding: 25px;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.5);
            min-width: 400px;
            max-width: 500px;
        }

        .memory-edit-modal.active {
            display: block;
        }

        .modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 998;
}

.modal-overlay.active {
    display: block;
}

        .memory-edit-modal h3 {
            margin-bottom: 15px;
            color: #ff6b35;
        }

        .memory-edit-modal input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1em;
        }

        .memory-edit-modal .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .memory-label {
            font-size: 0.7em;
            display: block;
            margin-top: 2px;
            color: #ff6b35;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .band-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .band-btn {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: bold;
        }

        .band-btn.active {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
            border-color: #ff6b35;
        }

        .band-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        .cat-log {
            background: #000;
            border-radius: 8px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .cat-log-entry {
            margin-bottom: 2px;
            opacity: 0.8;
        }

        .cat-log-entry.tx {
            color: #ff6b35;
        }

        .cat-log-entry.rx {
            color: #f7931e;
        }

        .cat-log-entry.error {
            color: #ff4757;
        }

        .volume-knob-container {
            width: 80px;
            height: 80px;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .volume-knob-container:active {
            cursor: grabbing;
        }

       .knobs-row {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    margin-top: 10px;
    /* This new rule forces all groups to stretch to the same height */
    align-items: stretch;
}

.knob-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    /* This replaces the fixed 'gap' and pushes the labels to the top/bottom */
    justify-content: space-between;
    padding: 5px 0; /* Adds a little vertical breathing room */
}

        .knob-group label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .knob-level {
            font-family: "Courier New", monospace;
            font-size: 0.9rem;
            text-align: center;
            color: #fff;
            margin-top: 2px;
        }

        .volume-knob-container,
        .volume-knob {
            display: flex !important;
            justify-content: center;
            align-items: center;
            visibility: visible !important;
        }

        .volume-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 1px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.1) 0deg, rgba(0, 0, 0, 0.07) 5deg, rgba(255, 255, 255, 0.1) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 1%, #c0c0c0 2%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 20% 20%, 100% 100%;
        }

        .volume-knob::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e5e5, #c0c0c0);
            background-image:
                repeating-radial-gradient(circle at 50% 50%, transparent 0%, transparent 10%, rgba(0, 0, 0, 0.03) 10.5%, transparent 11%);
            z-index: 1;
        }

        .volume-knob::after {
            content: "";
            position: absolute;
            width: 5px !important;
            height: 38px;
            background-color: #333 !important;
            border-radius: 5px;
            top: 5px;
            z-index: 3;
            transition: background-color 0.2s ease;
        }

        .volume-knob-center {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
        }

        .volume-knob:hover::after {
            background-color: #ff6b35 !important;
        }

        .volume-knob::before,
        .volume-knob::after,
        .volume-knob-center {
            pointer-events: none;
        }

        .tuning-knob::before,
        .tuning-knob::after,
        .tuning-knob-center {
            pointer-events: none;
        }

        /* Night Mode Toggle Styles */
        .night-mode-toggle-container {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .night-mode-toggle {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .night-mode-toggle:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .night-mode-toggle.active {
            background: rgba(255, 107, 53, 0.2);
            border-color: #ff6b35;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.3);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #666, #888);
            border-radius: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }

        .night-mode-toggle.active .toggle-slider {
            left: 32px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
        }

        .toggle-label {
            position: absolute;
            font-size: 0.6em;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
            z-index: 1;
            pointer-events: none;
        }

        .toggle-label.left {
            left: 6px;
        }

        .toggle-label.right {
            right: 6px;
        }

        .night-mode-toggle:not(.active) .toggle-label.left {
            color: #fff;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
        }

        .night-mode-toggle.active .toggle-label.right {
            color: #fff;
            text-shadow: 0 0 3px rgba(255, 107, 53, 0.8);
        }

        /* Audio Processing Panel Styles */
        .audio-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .fft-canvas {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            margin: 10px 0;
        }

        .waterfall-canvas {
            width: 100%;
            height: 200px;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            margin: 10px 0;
        }

        .audio-indicator {
            height: 20px;
            background: #222;
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }

        .audio-level {
            height: 100%;
            background: linear-gradient(90deg, #ff6b35, #f7931e);
            border-radius: 10px;
            transition: width 0.1s ease;
            width: 0%;
        }

        .audio-status {
            text-align: center;
            font-family: 'Courier New', monospace;
            color: #ff6b35;
            margin: 5px 0;
        }

       @media (max-width: 768px) {
    .volume-knob-container {
        width: 60px;
        height: 60px;
    }
    .knobs-row {
        gap: 8px;
    }
    
    .main-panel {
        grid-template-columns: 1fr;
    }
    
    .master-container {
        padding: 15px;
    }
    
    .header h1 {
        font-size: 1.8em;
    }
}

/*-- ---------------------------------------------------------*/

.master-container {
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid rgba(255, 107, 53, 0.3);
    border-radius: 20px;
    padding: 25px;
    margin-bottom: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
    position: relative;
}

.master-container::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, 
                rgba(255, 107, 53, 0.1), 
                rgba(247, 147, 30, 0.1));
    border-radius: 20px;
    z-index: -1;
    opacity: 0.5;
}

/* Frequency Keypad Modal */
.frequency-keypad-modal {
    display: none;
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    background: #1a1a2e !important;
    border: 2px solid #ff6b35 !important;
    border-radius: 15px;
    padding: 25px;
    z-index: 99999 !important;
    box-shadow: 0 0 30px rgba(255, 107, 53, 0.5);
    min-width: 320px;
    pointer-events: auto !important;
}

.frequency-keypad-modal.active {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}

.frequency-keypad-modal h3 {
    margin-bottom: 15px;
    color: #ff6b35;
    text-align: center;
}

.keypad-display {
    background: #000;
    border: 2px solid #ff6b35;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    text-align: right;
    font-family: 'Courier New', monospace;
    font-size: 1.8em;
    color: #ff6b35;
    min-height: 50px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
}

.keypad-buttons {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 15px;
}

.keypad-btn {
    padding: 15px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.2em;
    font-weight: bold;
    transition: all 0.2s ease;
}

.keypad-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
}

.keypad-btn:active {
    transform: translateY(0);
}

.keypad-btn.wide {
    grid-column: span 2;
}

.keypad-actions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}

.frequency-hint {
    text-align: center;
    font-size: 0.85em;
    color: rgba(255, 255, 255, 0.6);
    margin-bottom: 10px;
}

/* Generic Toggle Styles */
.control-toggle {
    position: relative;
    width: 60px;
    height: 30px;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
}

.control-toggle:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.4);
}

.control-toggle.active {
    background: rgba(255, 107, 53, 0.2);
    border-color: #ff6b35;
    box-shadow: 0 0 15px rgba(255, 107, 53, 0.3);
}

.control-toggle .toggle-slider {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 24px;
    height: 24px;
    background: linear-gradient(45deg, #666, #888);
    border-radius: 12px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 2;
}

.control-toggle.active .toggle-slider {
    left: 32px;
    background: linear-gradient(45deg, #ff6b35, #f7931e);
}

.control-toggle .toggle-label {
    position: absolute;
    font-size: 0.6em;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.6);
    transition: all 0.3s ease;
    z-index: 1;
    pointer-events: none;
}

.control-toggle .toggle-label.left { left: 6px; }
.control-toggle .toggle-label.right { right: 6px; }

.control-toggle:not(.active) .toggle-label.left {
    color: #fff;
    text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
}

.control-toggle.active .toggle-label.right {
    color: #fff;
    text-shadow: 0 0 3px rgba(255, 107, 53, 0.8);
}


/* Night Mode Dimming Styles */
body.night-mode-active .btn-primary,
body.night-mode-active .band-btn.active,
body.night-mode-active .mode-btn.active,
body.night-mode-active .memory-btn.memory-selected {
    background: linear-gradient(45deg, #a64522, #b56c15);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    color: #000; /* Corrected: Ensures text is always readable */
}

body.night-mode-active .lcd-row,
body.night-mode-active .memory-btn.memory-occupied {
    color: #d1562c;
    text-shadow: 0 0 8px rgba(209, 86, 44, 0.4);
}

body.night-mode-active .frequency-display.lcd-panel {
    border-color: #d1562c;
    box-shadow: 0 0 20px rgba(209, 86, 44, 0.2);
}

body.night-mode-active .status-text.connected {
    color: #d1562c;
    text-shadow: 0 0 8px rgba(209, 86, 44, 0.5);
}

body.night-mode-active .status-dot.connected {
    background: #d1562c;
}

body.night-mode-active .fft-canvas {
    filter: saturate(0.6) brightness(0.8);
}

/* S-Meter Styles */
.s-meter-container {
    background: #000;
    border: 2px solid #ff6b35;
    border-radius: 8px;
    padding: 10px;
    margin: 10px 0;
}

.s-meter-display {
    position: relative;
    height: 60px;
    background: linear-gradient(to bottom, #1a1a1a, #000);
    border-radius: 5px;
    overflow: hidden;
    margin-bottom: 8px;
}

.s-meter-scale {
    display: flex;
    justify-content: space-between;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 15px;
    font-size: 0.7em;
    color: rgba(255, 255, 255, 0.6);
    padding: 2px 5px;
    z-index: 2;
}

.s-meter-bar-container {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 35px;
    background: #0a0a0a;
}

.s-meter-bar {
    height: 100%;
    transition: width 0.1s ease-out;
    background: linear-gradient(to right, 
        #00ff00 0%, 
        #00ff00 55%, 
        #ffff00 55%, 
        #ffff00 77%, 
        #ff6b35 77%, 
        #ff0000 100%);
    box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
    position: relative;
    width: 0%;
}

.s-meter-peak {
    position: absolute;
    bottom: 0;
    width: 3px;
    height: 35px;
    background: #ff0000;
    box-shadow: 0 0 8px #ff0000;
    transition: left 0.05s ease-out;
    z-index: 3;
    left: 0%;
}

.s-meter-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.75em;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 3px;
    padding: 0 5px;
}

.s-meter-labels span {
    flex: 1;
    text-align: center;
}

.s-meter-labels span:nth-child(10),
.s-meter-labels span:nth-child(11),
.s-meter-labels span:nth-child(12) {
    color: #ff6b35;
    font-weight: bold;
}

.s-meter-readout {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    padding: 5px 10px;
    background: rgba(255, 107, 53, 0.1);
    border-radius: 5px;
}

.s-meter-value {
    font-family: 'Courier New', monospace;
    font-size: 1.2em;
    color: #ff6b35;
    font-weight: bold;
}

.s-meter-dbm {
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
    color: rgba(255, 255, 255, 0.7);
}

.s-meter-peak-value {
    font-family: 'Courier New', monospace;
    font-size: 0.85em;
    color: #ff4757;
}

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>QRP-Labs QDX Commander with Digital Audio by DJ0CU/G4ADF</h1>
            <p>QRP Digital Communications Interface with Real-Time Audio Processing</p>
        </div>
<div class="master-container">
        <div class="main-panel">
            <div class="left-panel">
			
			
			<div class="panel" id="dspPanel">
    <h3>DSP Filter 🎛️</h3>
    <div class="control-group">
        <label>Filter Bandwidth</label>
        <select id="dspFilterSelect">
            <option value="SSB_WIDE">SSB Wide (3.2 kHz)</option>
            <option value="SSB_2400" selected>SSB Normal (2.4 kHz)</option>
            <option value="SSB_1800">SSB Narrow (1.8 kHz)</option>
            <option value="CW_500">CW (500 Hz)</option>
            <option value="CW_250">CW Narrow (250 Hz)</option>
        </select>
    </div>

 <div class="control-group" style="margin-top: 15px;">
        <label>AGC (Automatic Gain Control)</label>
        <div class="control-toggle" id="agcToggle" style="margin: 10px auto;">
            <div class="toggle-slider"></div>
            <span class="toggle-label left">OFF</span>
            <span class="toggle-label right">ON</span>
        </div>
    </div>
    
    <div class="control-group" id="agcSettings">
        <label>AGC Strength</label>
        <select id="agcPreset">
            <option value="weak">Weak (4:1)</option>
            <option value="medium" selected>Medium (12:1)</option>
            <option value="strong">Strong (20:1)</option>
        </select>
    </div>

<div class="control-group" id="agcMeterGroup" style="margin-top: 10px;">
    <label>AGC Reduction</label>
    <div style="background: #222; border-radius: 5px; height: 20px; position: relative; overflow: hidden;">
        <div id="agcReductionMeter" style="background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722); height: 100%; width: 0%; transition: width 0.1s;"></div>
    </div>
    <div id="agcReductionText" style="text-align: center; font-size: 0.8em; color: #ff6b35; margin-top: 5px;">0 dB</div>
</div>




</div>

                <div class="panel" id="serialPanel">
	

<!-- ------------------------------------------------------------ -->

                    <h3>Serial Connection</h3>
                    <div class="control-group">
                        <label>Baud Rate</label>
                        <select id="baudRate">
                            <option value="9600">9600</option>
                            <option value="19200">19200</option>
                            <option value="38400">38400</option>
                            <option value="57600">57600</option>
                            <option value="115200" selected>115200</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button id="connectBtn" class="btn btn-primary">Connect Serial</button>
                    </div>
                </div>

  <div class="panel" id="audioPanel">
    <h3>Digital Audio</h3>
    
    <!-- Quick Status -->
    <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center;">
        <div class="audio-status" id="audioStatus">Select QDX Audio Device</div>
    </div>
    
    <!-- Quick Controls -->
    <div class="audio-controls" style="margin-bottom: 15px;">
        <button id="startAudioBtn" class="btn btn-primary">Start Audio</button>
        <button id="stopAudioBtn" class="btn btn-secondary">Stop Audio</button>
    </div>
    
    
    
    <!-- Collapsible Advanced Settings -->
    <details style="margin-top: 10px;">
        <summary style="cursor: pointer; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 10px;">
            ⚙️ Audio Device Settings
        </summary>
        
        <!-- RX Settings -->
        <div style="background: rgba(0,100,0,0.1); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
            <label style="color: #4CAF50; font-weight: bold; font-size: 0.9em;">📻 RECEIVE (RX)</label>
            <div class="control-group">
                <label style="font-size: 0.85em;">QDX Audio Input</label>
                <select id="audioInputDevice" style="width:100%; padding: 8px; font-size: 0.9em;"></select>
            </div>
            <div class="control-group">
                <label style="font-size: 0.85em;">PC Speakers</label>
                <select id="audioOutputDevice" style="width:100%; padding: 8px; font-size: 0.9em;"></select>
            </div>
        </div>
        
        <!-- TX Settings -->
      
    </details>
    
    <!-- Other Settings (collapsed by default) -->
   <!-- <details style="margin-top: 10px;">
        <summary style="cursor: pointer; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
            ⚙️ Advanced Audio Settings
        </summary>
       <div class="control-group" style="margin-top: 10px;">
            <label>Sample Rate</label>
            <select id="sampleRate">
                <option value="8000">8 kHz</option>
                <option value="12000">12 kHz</option>
                <option value="16000">16 kHz</option>
                <option value="22050">22.05 kHz</option>
                <option value="44100">44.1 kHz</option>
                <option value="48000" selected>48 kHz</option>
            </select>
        </div> 
        <div class="control-group">
            <label>Audio Output Volume</label>
            <input type="range" id="audioVolumeSlider" class="slider" min="0" max="100" value="50" title="RX Audio Volume (50% = unity gain, 100% = 2x boost)">
            <span id="audioVolumeLevel">50%</span>
        </div>
     <!--    <button id="testAudioBtn" class="btn btn-secondary" style="width: 100%; margin-top: 10px;">Test Audio System</button> 
    </details> -->

    
   <!-- <div class="audio-controls">
        <button id="startAudioBtn" class="btn btn-primary">Start Audio</button>
        <button id="stopAudioBtn" class="btn btn-secondary">Stop Audio</button>
        <button id="testAudioBtn" class="btn btn-secondary" style="grid-column: span 2; margin-top: 10px;">Test Audio System</button>
    </div> -->

                    <div class="control-group">
                        <label>Sample Rate</label>
                        <select id="sampleRate">
                            <option value="8000">8 kHz</option>
                            <option value="12000">12 kHz</option>
                            <option value="16000">16 kHz</option>
                            <option value="22050">22.05 kHz</option>
                            <option value="44100">44.1 kHz</option>
                            <option value="48000" selected>48 kHz</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Audio Output</label>
                        <input type="range" id="audioVolumeSlider" class="slider" min="0" max="100" value="50">
                        <span id="audioVolumeLevel">50%</span>
                    </div>
                    <div class="audio-indicator">
                        <div class="audio-level" id="audioLevel"></div>
                    </div>
                    <div class="audio-status" id="audioStatus">Select QDX Audio Device</div>
                
				<!-- Add this right before the </div> closing tag of the TX audio section -->
<div class="control-group" style="margin-top: 10px;">
    <label>TX Audio Level</label>
    <div style="background: #222; border-radius: 5px; height: 20px; position: relative; overflow: hidden;">
        <div id="txAudioMeter" style="background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722); height: 100%; width: 0%; transition: width 0.05s;"></div>
    </div>
    <div id="txAudioLevelText" style="text-align: center; font-size: 0.8em; color: #ff6b35; margin-top: 5px;">0%</div>
</div>
			<!-- Add this in the audio panel -->
<!-- Add this in the audio panel -->

				</div>

                <div class="panel" id="modePanel">
                    <h3>Operating Mode</h3>
                    <div class="mode-buttons">
                        <div class="mode-btn active" data-mode="USB" data-catmode="2">USB</div>
                        <div class="mode-btn" data-mode="LSB" data-catmode="1">LSB</div>
                    </div>
                </div>

                <div class="panel" id="stepPanel">
                    <h3>Tuning Step</h3>
                    <div class="control-group">
                        <label>Step Size</label>
                        <select id="stepSize">
                            <option value="1">1 Hz</option>
                            <option value="10"selected>10 Hz</option>
                            <option value="100">100 Hz</option>
                            <option value="1000">1 kHz</option>
                            <option value="10000">10 kHz</option>
                        </select>
                    </div>
                </div>

                <div class="panel" id="bandPanel">
                    <h3>Band</h3>
                    <div class="band-buttons">
                        <div class="band-btn" data-band="80">80m</div>
                        <div class="band-btn" data-band="40">40m</div>
                        <div class="band-btn" data-band="30">30m</div>
                        <div class="band-btn active" data-band="20">20m</div>
                        <div class="band-btn" data-band="17">17m</div>
                        <div class="band-btn" data-band="15">15m</div>
                        <div class="band-btn" data-band="12">12m</div>
                        <div class="band-btn" data-band="10">10m</div>
                    </div>
                </div>

                <div class="panel" id="catPanel">
                    <h3>CAT Monitor</h3>
                    <div class="cat-log" id="catLog"></div>
                </div>
            </div>

            <div class="center-panel">
                <div class="panel frequency-display lcd-panel" id="lcdPanel">
                    <div id="lcdRow1" class="lcd-row">QDX Commander...</div>
                    <div id="lcdRow2" class="lcd-row">Connect Radio</div>
                </div>

                <div class="panel" id="tuningPanel">
                    <h3 style="text-align: center; margin-bottom: 15px;">Main Tuning</h3>
                    <div class="tuning-knob-container" id="tuningKnobContainer">
                        <div class="frequency-markings" id="frequencyMarkings"></div>
                        <div class="tuning-knob" id="tuningKnob" tabindex="0" role="slider" aria-label="Frequency Tuning" aria-valuemin="100000" aria-valuemax="999999999" aria-valuenow="14205000">
                            <div class="tuning-knob-center"></div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="spectrumPanel">
    <h3>Spectrum Display</h3>
    <canvas class="fft-canvas" id="fftCanvas" width="400" height="150"></canvas>
    
    <!-- S-Meter -->
    <div class="s-meter-container">
        <div class="s-meter-display">
            <div class="s-meter-scale">
                <span>S-METER</span>
                <span id="sMeterMode">RX</span>
            </div>
            <div class="s-meter-bar-container">
                <div class="s-meter-bar" id="sMeterBar"></div>
                <div class="s-meter-peak" id="sMeterPeak"></div>
            </div>
        </div>
        <div class="s-meter-labels">
            <span>1</span>
            <span>2</span>
            <span>3</span>
            <span>4</span>
            <span>5</span>
            <span>6</span>
            <span>7</span>
            <span>8</span>
            <span>9</span>
            <span>+20</span>
            <span>+40</span>
            <span>+60</span>
        </div>
        <div class="s-meter-readout">
            <div class="s-meter-value" id="sMeterValue">S0</div>
            <div class="s-meter-dbm" id="sMeterDbm">-127 dBm</div>
            <div class="s-meter-peak-value" id="sMeterPeakValue">Peak: S0</div>
        </div>
    </div>
    
    <div class="control-group">
        <label>FFT Size</label>
        <select id="fftSize">
            <option value="256">256</option>
            <option value="512">512</option>
            <option value="1024" selected>1024</option>
            <option value="2048">2048</option>
        </select>
    </div>
</div>

                <div class="panel" id="vfoPanel">
                    <h3>VFO</h3>
                    <div class="controls-grid">
                        <button class="btn btn-primary" id="vfoA">VFO A</button>
                        <button class="btn btn-secondary" id="vfoB">VFO B</button>
                    </div>
                </div>

               
                
            </div>

            <div class="right-panel">
                <div class="panel" id="waterfallPanel">
                    <h3>Waterfall Display</h3>
                    <canvas class="waterfall-canvas" id="waterfallCanvas" width="400" height="200"></canvas>
                    <div class="control-group">
                        <label>Speed</label>
                        <input type="range" id="waterfallSpeed" class="slider" min="1" max="10" value="1">
                    </div>
                </div>

            <div class="panel" id="controlsPanel">
    <h3>Controls</h3>
    
    <div class="knobs-row">

        <div class="knob-group">
            <label>AF Gain</label>
            <div class="volume-knob-container">
                <div class="volume-knob" id="volumeKnob" tabindex="0" role="slider" aria-label="Volume Control" aria-valuemin="0" aria-valuemax="100" aria-valuenow="75">
                    <div class="volume-knob-center"></div>
                </div>
            </div>
            <div class="knob-level" id="volumeLevel">75%</div>
        </div>

        <div class="knob-group">
            <label>Auto Tune</label>
            <div class="night-mode-toggle-container">
                <div class="control-toggle" id="continuousAutoTuneToggle">
                    <div class="toggle-slider"></div>
                    <span class="toggle-label left">OFF</span>
                    <span class="toggle-label right">ON</span>
                </div>
            </div>
            <div class="knob-level" id="continuousAutoTuneStatus">DISABLED</div>
        </div>
        
        <div class="knob-group">
            <label>Night Mode</label>
            <div class="night-mode-toggle-container">
                <div class="control-toggle" id="nightModeToggle">
                    <div class="toggle-slider"></div>
                    <span class="toggle-label left">OFF</span>
                    <span class="toggle-label right">ON</span>
                </div>
            </div>
            <div class="knob-level" id="nightModeStatus">ENABLED</div>
        </div>

    </div> <div style="text-align: center; margin-top: 20px;">
        <button id="autoTuneNowBtn" class="btn btn-primary" style="width: 60%;">AutoTune Now</button>
    </div>
</div>      

                <div class="panel" id="memoryPanel">
                    <h3>Memory</h3>
                    <div class="controls-grid">
                        <button class="btn btn-secondary" id="storeBtn">Store</button>
                        <button class="btn btn-secondary" id="recallBtn">Recall</button>
                        <button class="btn btn-secondary" id="editBtn">Edit</button>
                        <button class="btn btn-secondary" id="clearBtn">Clear</button>
                    </div>
                    <div class="memory-buttons">
                        <div class="memory-btn" data-channel="1">M1</div>
                        <div class="memory-btn" data-channel="2">M2</div>
                        <div class="memory-btn" data-channel="3">M3</div>
                        <div class="memory-btn" data-channel="4">M4</div>
                        <div class="memory-btn" data-channel="5">M5</div>
                        <div class="memory-btn" data-channel="6">M6</div>
                        <div class="memory-btn" data-channel="7">M7</div>
                        <div class="memory-btn" data-channel="8">M8</div>
                        <div class="memory-btn" data-channel="9">M9</div>
                        <div class="memory-btn" data-channel="10">M10</div>
                    </div>
                    <div class="controls-grid" style="margin-top: 10px;">
                        <button class="btn btn-secondary" id="exportBtn">Export</button>
                        <button class="btn btn-secondary" id="importBtn">Import</button>
                        <button class="btn btn-secondary" id="clearAllBtn" style="grid-column: span 2;">Clear All</button>
                    </div>
                  <input type="file" id="importFile" accept=".json" style="display: none;">
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span class="status-text disconnected" id="statusText">DISCONNECTED</span>
            </div>
            <div>QDX CAT Interface with Real-Time Audio</div>
            <div id="currentTime"></div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="memory-edit-modal" id="memoryEditModal">
	
	
	
	
	
	
        <h3>Edit Memory Channel <span id="editChannelNumber"></span></h3>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Frequency (MHz)</label>
            <input type="text" id="memoryFreqInput" placeholder="14.205" style="margin-bottom: 5px;">
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Mode</label>
            <select id="memoryModeSelect" style="width: 100%; padding: 10px; margin-bottom: 5px; background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px;">
                <option value="USB">USB</option>
                <option value="LSB">LSB</option>
            </select>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Band</label>
            <select id="memoryBandSelect" style="width: 100%; padding: 10px; margin-bottom: 5px; background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px;">
                <option value="80">80m</option>
                <option value="40">40m</option>
                <option value="30">30m</option>
                <option value="20">20m</option>
                <option value="17">17m</option>
                <option value="15">15m</option>
                <option value="12">12m</option>
                <option value="10">10m</option>
            </select>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Label/Description</label>
            <input type="text" id="memoryLabelInput" placeholder="Enter label (e.g., FT8 Frequency)">
        </div>
        
        <div class="btn-group">
            <button class="btn btn-primary" id="saveMemoryEdit">Save</button>
            <button class="btn btn-secondary" id="cancelMemoryEdit">Cancel</button>
        </div>
		  </div>
		
		<div class="frequency-keypad-modal" id="frequencyKeypadModal">
        <h3>Enter Frequency</h3>
        <div class="keypad-display" id="keypadDisplay">14.205</div>
        <div class="frequency-hint">Enter frequency in MHz (e.g., 14.205)</div>
        <div class="keypad-buttons">
    <button class="keypad-btn" data-value="1">1</button>
    <button class="keypad-btn" data-value="2">2</button>
    <button class="keypad-btn" data-value="3">3</button>
    <button class="keypad-btn" data-value="4">4</button>
    <button class="keypad-btn" data-value="5">5</button>
    <button class="keypad-btn" data-value="6">6</button>
    <button class="keypad-btn" data-value="7">7</button>
    <button class="keypad-btn" data-value="8">8</button>
    <button class="keypad-btn" data-value="9">9</button>
    <button class="keypad-btn" data-value=".">.</button>
    <button class="keypad-btn" data-value="0">0</button>
    
    <button class="keypad-btn" data-action="clear">C</button> 
</div>
<div class="keypad-actions">
    <button class="keypad-btn" data-action="backspace" style="width:100%">⌫ Backspace</button>
    <button class="btn btn-secondary" id="keypadCancel">Cancel</button>
    <button class="btn btn-primary" id="keypadEnter">Enter</button>
</div>
    </div>
		
		
  
</body>
    <script>
     
        /**
         * Goertzel algorithm implementation.
         * Credit: https://github.com/Hadevsh/Morsen
         * This class is used for efficient single-tone detection.
         */
        class Goertzel {
            constructor(options) {
                this.options = options || {};
                this.sampleRate = this.options.sampleRate || 44100;
                this.frequency = this.options.frequency;
                this.blockSize = this.options.blockSize || 512;
                this.refresh();
            }
            refresh() {
                const k = Math.floor(0.5 + (this.blockSize * this.frequency) / this.sampleRate);
                const omega = (2 * Math.PI * k) / this.blockSize;
                this.sine = Math.sin(omega);
                this.cosine = Math.cos(omega);
                this.coeff = 2 * this.cosine;
                this.reset();
            }
            reset() {
                this.q0 = 0;
                this.q1 = 0;
                this.q2 = 0;
            }
            run(samples) {
                const magnitude = (index) => {
                    return Math.sqrt(
                        this.q1 * this.q1 +
                        this.q2 * this.q2 -
                        this.q1 * this.q2 * this.coeff
                    );
                };
                for (let i = 0; i < samples.length; i++) {
                    this.q0 = this.coeff * this.q1 - this.q2 + samples[i];
                    this.q2 = this.q1;
                    this.q1 = this.q0;
                }
                const result = magnitude();
                this.reset();
                return result;
            }
        }

        class QDXAudioProcessor {
         constructor(qdxInterface) {
    // --- 1. Initialize all properties first ---
    this.qdxInterface = qdxInterface;
    this.audioContext = null;  // For RX
    this.txAudioContext = null; 
    this.analyser = null;
    this.gainNode = null;
    this.dspFilterNode = null;
    this.fftSize = 1024;
    this.sampleRate = 48000;
    this.isStreaming = false;
   this.audioVolume = 1.0; // Start at 100% (which equals 2x with new multiplier)
    this.microphone = null;
    this.sourceNode = null;
    this.fftCanvas = document.getElementById('fftCanvas');
    this.fftCtx = this.fftCanvas.getContext('2d');
    this.waterfallCanvas = document.getElementById('waterfallCanvas');
    this.waterfallCtx = this.waterfallCanvas.getContext('2d');
    this.waterfallSpeed = 1;
    this.animationFrame = null;
    this.audioInputs = [];
    this.audioOutputs = [];
    this.selectedDeviceId = null;
    this.devicesLoaded = false;
    this.agcNode = null;
    this.agcEnabled = true;
    this.agcThreshold = -24;
    this.agcRatio = 12;
    this.agcAttack = 0.003;
    this.agcRelease = 0.25;
  /*  this.isTransmitting = false;
    this.txStarting = false; // NEW: Prevent rapid PTT triggering
    this.txMicStream = null;
    this.txSourceNode = null;
    this.txGainNode = null;
    this.txOutputGain = null;
    this.hilbertProcessor = null;
    this.txPhase = 0.0;
    this.selectedMicId = null;
    this.txAnalyser = null;
    this.inputGainNode = null;
    this.scopeCanvas = document.getElementById('scopeCanvas');
    this.scopeCtx = this.scopeCanvas.getContext('2d'); 
    this.selectedTxOutputId = null; 
    this.currentProfile = 'natural';
    this.wasStreamingBeforeTx = false; // NEW: Track RX state before TX
    this.preTransmitGain = null; // NEW: Store RX gain before muting */
    // S-Meter properties
this.sMeterValue = 0;
this.sMeterPeak = 0;
this.sMeterPeakDecay = 0;
this.sMeterSmoothing = 0.7; // Higher = smoother but slower response
this.sMeterPeakHoldTime = 1000; // ms to hold peak
this.sMeterLastPeakTime = 0;
    // --- 2. Now, call initialization functions ---
    this.initAudioProcessing();
    this.updateAudioButtons();
    this.qdxInterface.logCAT('QDX Audio Processor ready', 'info');
}


 async initAudioProcessing() {
    try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.audioContext = new AudioContext({
            sampleRate: this.sampleRate
        });

        // 1. Create INPUT GAIN NODE (prevents clipping)
        this.inputGainNode = this.audioContext.createGain();
        this.inputGainNode.gain.value = 0.5; // Start at 50% to prevent clipping
        this.qdxInterface.logCAT('Input gain stage created', 'info');

        // 2. Create the Analyser Node
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = this.fftSize;
        this.analyser.smoothingTimeConstant = 0.3;
        this.analyser.minDecibels = -90;
        this.analyser.maxDecibels = -10;

        // 3. Create the Gain (Volume) Node for output
        this.gainNode = this.audioContext.createGain();
        this.gainNode.gain.value = this.audioVolume;
        this.gainNode.connect(this.audioContext.destination);

        // 4. Create AGC Node
        this.agcNode = this.audioContext.createDynamicsCompressor();
        this.agcNode.threshold.value = -30;
        this.agcNode.knee.value = 40;
        this.agcNode.ratio.value = 20;
        this.agcNode.attack.value = 0.003;
        this.agcNode.release.value = 0.25;
        this.qdxInterface.logCAT('AGC compressor created', 'info');

        // 5. Create the DSP Filter Node
        this.dspFilterNode = this.audioContext.createBiquadFilter();
        this.dspFilterNode.type = 'bandpass';
        this.dspFilterNode.frequency.value = 1500;
        this.dspFilterNode.Q.value = 1500 / 2400;

        this.qdxInterface.logCAT('Web Audio API initialized with AGC', 'info');
        
        // Load devices after a short delay
        setTimeout(() => {
            this.loadAudioDevices();
        }, 500);

    } catch (error) {
        this.qdxInterface.logCAT(`Audio init error: ${error.message}`, 'error');
        console.error('Full init error:', error);
    }
}



            async loadAudioDevices() {
  try {
    this.qdxInterface.logCAT('Loading audio devices...', 'info');
    if (!navigator.mediaDevices?.enumerateDevices) {
      throw new Error('enumerateDevices not supported');
    }

    // Do NOT call getUserMedia here (causes prompts).
    // If labels are empty (no prior grant), we can still list deviceIds;
    // labels will populate after the first real capture grant.
    const devices = await navigator.mediaDevices.enumerateDevices();
    this.audioInputs  = devices.filter(d => d.kind === 'audioinput');
    this.audioOutputs = devices.filter(d => d.kind === 'audiooutput');

    this.updateAudioDeviceSelectors();
    this.updateAudioStatus('Audio devices loaded');
  } catch (error) {
    this.qdxInterface.logCAT(`Device enumeration failed: ${error.message}`, 'error');
  }
}


 updateAudioDeviceSelectors() {
    try {
        const audioPanel = document.getElementById('audioPanel');
        
        // POPULATE RX INPUT (QDX USB Audio OUT)
        const rxInputSelect = document.getElementById('audioInputDevice');
        if (rxInputSelect) {
            rxInputSelect.innerHTML = '<option value="">Use System Default Input</option>';
            if (this.audioInputs.length > 0) {
                this.audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Audio Input ${index + 1}`;
                    
                    if (device.label && (device.label.toLowerCase().includes('qdx') || 
                                         device.label.toLowerCase().includes('usb audio'))) {
                        option.textContent += ' ⭐ (Recommended for QDX)';
                        option.selected = true;
                    }
                    
                    rxInputSelect.appendChild(option);
                });
            }
            
            rxInputSelect.addEventListener('change', (e) => {
                this.selectedDeviceId = e.target.value;
                this.qdxInterface.logCAT(`RX Input set to: ${e.target.options[e.target.selectedIndex].text}`, 'info');
            });
        }
        
        // POPULATE SPEAKER OUTPUT (PC Speakers)
        const speakerSelect = document.getElementById('audioOutputDevice');
        if (speakerSelect) {
            speakerSelect.innerHTML = '<option value="">Use System Default Output</option>';
            if (this.audioOutputs.length > 0) {
                this.audioOutputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Audio Output ${index + 1}`;
                    
                    if (device.label && !device.label.toLowerCase().includes('qdx') && 
                        (device.label.toLowerCase().includes('speaker') || 
                         device.label.toLowerCase().includes('headphone') ||
                         device.label.toLowerCase().includes('realtek'))) {
                        option.textContent += ' 🔊 (Recommended)';
                        option.selected = true;
                    }
                    
                    speakerSelect.appendChild(option);
                });
            }
            
            speakerSelect.addEventListener('change', (e) => {
                const deviceId = e.target.value;
                this.qdxInterface.logCAT(`Speakers set to: ${e.target.options[e.target.selectedIndex].text}`, 'info');
                this.setAudioOutput(deviceId);
            });
        }
        
        // 🆕 POPULATE TX AUDIO OUTPUT (to QDX LINE IN)
      
      
        
      
		

		
		
        this.qdxInterface.logCAT('Audio device selectors populated', 'info');
        
    } catch (error) {
        console.error('Failed to create device selectors:', error);
    }
}
			
			












    
			
			
			

            async setAudioOutput(deviceId) {
                try {
                    if (typeof this.audioContext.setSinkId !== 'function') {
                        throw new Error('Browser does not support changing audio output.');
                    }
                    await this.audioContext.setSinkId(deviceId);
                    this.qdxInterface.logCAT(`Audio output successfully set.`, 'info');
                } catch (error) {
                    this.qdxInterface.logCAT(`Failed to set audio output: ${error.message}`, 'error');
                }
            }

       
            async testAudioSystem() {
                 try {
                    this.qdxInterface.logCAT('Testing audio system...', 'info');
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('getUserMedia not supported');
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    if (this.audioContext) this.qdxInterface.logCAT(`Audio context state: ${this.audioContext.state}`, 'info');
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.qdxInterface.logCAT(`Found ${devices.filter(d => d.kind === 'audioinput').length} audio input devices`, 'info');
                    this.updateAudioStatus('Audio System Test Complete');
                } catch (error) {
                    this.qdxInterface.logCAT(`Audio system test failed: ${error.message}`, 'error');
                }
            }

 
            async stopAudioStreaming() {
                this.isStreaming = false;
                if (this.microphone) {
                    this.microphone.getTracks().forEach(track => track.stop());
                    this.microphone = null;
                }
                if (this.sourceNode) {
                    this.sourceNode.disconnect();
                    this.sourceNode = null;
                }
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                this.updateAudioStatus('Select QDX Audio Device');
                this.updateAudioButtons();
                this.qdxInterface.logCAT('Audio streaming stopped', 'info');
				
				 // --- ADD THIS BLOCK to create the TX analyser ---
      //  this.txAnalyser = this.audioContext.createAnalyser();
        this.txAnalyser.fftSize = 2048; // Higher resolution for a detailed scope
        // --- End of new block ---
            }

// In the QDXAudioProcessor class













// REPLACE your existing startAudioProcessingLoop() with this updated version
startAudioProcessingLoop() {
    if (this.isStreaming || this.isTransmitting) {
        // Always draw the receiver displays if streaming
        if (this.isStreaming) {
            this.updateSpectrumDisplay();
            this.updateWaterfallDisplay();
            this.updateAudioLevelMeter();
        }
        
        // Only draw the TX scope if transmitting
        if (this.isTransmitting) {
            this.drawTxScope();
        }
        
        this.animationFrame = requestAnimationFrame(() => this.startAudioProcessingLoop());
    }
}








//end of start transmission









           updateSpectrumDisplay() {
                if (!this.analyser) return;
                const ctx = this.fftCtx;
                const width = this.fftCanvas.width;
                const height = this.fftCanvas.height;
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(freqData);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                const binWidth = width / freqData.length;
                for (let i = 0; i < freqData.length; i++) {
                    const barHeight = (freqData[i] / 255) * height;
                    ctx.fillStyle = '#ff6b35';
                    ctx.fillRect(i * binWidth, height - barHeight, binWidth - 1, barHeight);
                }
            }

          updateWaterfallDisplay() {
    if (!this.analyser) return;
    
    const ctx = this.waterfallCtx;
    const width = this.waterfallCanvas.width;
    const height = this.waterfallCanvas.height;
    const freqData = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteFrequencyData(freqData);
    
    // Scroll existing waterfall down
    const imageData = ctx.getImageData(0, 0, width, height - this.waterfallSpeed);
    ctx.putImageData(imageData, 0, this.waterfallSpeed);
    
    // Draw new line at top
    for (let i = 0; i < freqData.length; i++) {
        const value = freqData[i];
        const hue = (1 - value / 255) * 240; // Blue to red
        ctx.fillStyle = `hsl(${hue}, 100%, ${value / 255 * 50}%)`;
        const x = (i / freqData.length) * width;
        ctx.fillRect(x, 0, width / freqData.length, this.waterfallSpeed);
    }
}
             updateAudioLevelMeter() {
    if (!this.analyser) return;
    
    const timeData = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteTimeDomainData(timeData);
    
    let sum = 0;
    for (let i = 0; i < timeData.length; i++) {
        const sample = (timeData[i] - 128) / 128;
        sum += sample * sample;
    }
    const rms = Math.sqrt(sum / timeData.length);
    const level = Math.min(100, rms * 100 * 10);
    
    const levelElement = document.getElementById('audioLevel');
    levelElement.style.width = `${level}%`;
    
    // UPDATE AGC METER
    if (this.agcNode && this.agcEnabled) {
        const reduction = this.agcNode.reduction;
        const reductionPercent = Math.min(100, Math.abs(reduction) * 5);
        const meterElement = document.getElementById('agcReductionMeter');
        const textElement = document.getElementById('agcReductionText');
        
        if (meterElement) {
            meterElement.style.width = `${reductionPercent}%`;
        }
        if (textElement) {
            textElement.textContent = `${Math.abs(reduction).toFixed(1)} dB`;
        }
    }

    // Update S-Meter
    this.updateSMeter();
}

updateSMeter() {
    if (!this.analyser) return;
    
    // Get frequency domain data
    const freqData = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteFrequencyData(freqData);
    
    // Focus on voice frequency range (300 Hz - 3000 Hz)
    const sampleRate = this.audioContext.sampleRate;
    const fftSize = this.analyser.fftSize;
    const freqPerBin = sampleRate / fftSize;
    
    const minBin = Math.floor(300 / freqPerBin);
    const maxBin = Math.ceil(3000 / freqPerBin);
    
    // Find the peak power in voice range (not average)
    let maxPower = 0;
    for (let i = minBin; i < maxBin && i < freqData.length; i++) {
        if (freqData[i] > maxPower) {
            maxPower = freqData[i];
        }
    }
    
    // Convert to dBFS (0-255 scale to dB)
    // Apply more realistic scaling
    const dbfs = maxPower > 0 ? 20 * Math.log10(maxPower / 255) : -100;
    
    // Convert dBFS to approximate dBm with adjusted calibration
    // This is calibrated to match typical S-meter behavior
    const dbm = dbfs - 100; // Much more conservative offset
    
    // Convert dBm to S-units
    // S9 = -73 dBm, each S-unit = 6 dB
    let sValue;
    let sUnit;
    
    if (dbm <= -127) {
        sValue = 0;
        sUnit = 'S0';
    } else if (dbm >= -73) {
        // Above S9, show as S9+XX dB
        const overS9 = dbm + 73;
        sValue = 9 + (overS9 / 60) * 3;
        if (overS9 < 10) {
            sUnit = `S9+${Math.round(overS9)}`;
        } else {
            sUnit = `S9+${Math.round(overS9 / 10) * 10}`;
        }
    } else {
        // S1 to S9 range
        sValue = 1 + (dbm + 121) / 6;
        sValue = Math.max(0, Math.min(9, sValue));
        sUnit = `S${Math.floor(sValue)}`;
    }
    
    // Apply smoothing with faster response
    this.sMeterValue = (this.sMeterSmoothing * this.sMeterValue) + 
                       ((1 - this.sMeterSmoothing) * sValue);
    
    // Update peak with hold
    const now = Date.now();
    if (this.sMeterValue > this.sMeterPeak || 
        (now - this.sMeterLastPeakTime) > this.sMeterPeakHoldTime) {
        if (this.sMeterValue > this.sMeterPeak) {
            this.sMeterPeak = this.sMeterValue;
            this.sMeterLastPeakTime = now;
        } else {
            // Decay peak slowly
            this.sMeterPeak = Math.max(this.sMeterValue, this.sMeterPeak - 0.05);
        }
    }
    
    // Update display
    this.updateSMeterDisplay(this.sMeterValue, sUnit, dbm);
}



updateSMeterDisplay(sValue, sUnit, dbm) {
    // Update bar width (0-12 range maps to 0-100%)
    const barWidth = Math.min(100, (sValue / 12) * 100);
    const sMeterBar = document.getElementById('sMeterBar');
    if (sMeterBar) {
        sMeterBar.style.width = `${barWidth}%`;
    }
    
    // Update peak indicator
    const peakWidth = Math.min(100, (this.sMeterPeak / 12) * 100);
    const sMeterPeak = document.getElementById('sMeterPeak');
    if (sMeterPeak) {
        sMeterPeak.style.left = `${peakWidth}%`;
    }
    
    // Update text displays
    const sMeterValue = document.getElementById('sMeterValue');
    if (sMeterValue) {
        sMeterValue.textContent = sUnit;
    }
    
    const sMeterDbm = document.getElementById('sMeterDbm');
    if (sMeterDbm) {
        sMeterDbm.textContent = `${dbm.toFixed(0)} dBm`;
    }
    
    // Update peak value display
    const peakDbm = -121 + (this.sMeterPeak - 1) * 6;
    let peakUnit;
    if (this.sMeterPeak < 1) {
        peakUnit = 'S0';
    } else if (this.sMeterPeak <= 9) {
        peakUnit = `S${Math.floor(this.sMeterPeak)}`;
    } else {
        const overS9 = (this.sMeterPeak - 9) * 20;
        peakUnit = `S9+${Math.round(overS9)}`;
    }
    
    const sMeterPeakValue = document.getElementById('sMeterPeakValue');
    if (sMeterPeakValue) {
        sMeterPeakValue.textContent = `Peak: ${peakUnit}`;
    }
    
    // Update mode indicator (RX/TX)
    const sMeterMode = document.getElementById('sMeterMode');
    if (sMeterMode) {
        sMeterMode.textContent = this.isTransmitting ? 'TX' : 'RX';
        sMeterMode.style.color = this.isTransmitting ? '#ff4757' : '#4CAF50';
    }
}



           
            updateAudioStatus(status) {
			document.getElementById('audioStatus').textContent = status;
			}
			
			
			
			
			
			
			
			
			
			
			
			
			

 async startAudioStreaming() {
    try {
        this.qdxInterface.logCAT('Attempting to start audio streaming...', 'info');

        // Check if devices have been loaded
        if (!this.devicesLoaded) {
            await this.loadAudioDevices();
            this.devicesLoaded = true;
        }

        const constraints = {
            audio: {
                deviceId: this.selectedDeviceId ? { exact: this.selectedDeviceId } : undefined,
                sampleRate: this.sampleRate,
                channelCount: 1,
                autoGainControl: false,
                noiseSuppression: false,
                echoCancellation: false
            }
        };

        this.microphone = await navigator.mediaDevices.getUserMedia(constraints);
        
        if (this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
        }
        
        this.sourceNode = this.audioContext.createMediaStreamSource(this.microphone);

        // BUILD SIGNAL CHAIN STEP BY STEP WITH NULL CHECKS
        
        // Start of chain
        let currentNode = this.sourceNode;
        
        // Add input gain if it exists
        if (this.inputGainNode) {
            currentNode.connect(this.inputGainNode);
            currentNode = this.inputGainNode;
            this.qdxInterface.logCAT('Input gain stage connected', 'info');
        }
        
        // Add DSP filter
        if (this.dspFilterNode) {
            currentNode.connect(this.dspFilterNode);
            currentNode = this.dspFilterNode;
        }
        
        // Add AGC if enabled and exists
        if (this.agcEnabled && this.agcNode) {
            currentNode.connect(this.agcNode);
            currentNode = this.agcNode;
            this.qdxInterface.logCAT('AGC stage connected and active', 'info');
        } else {
            this.qdxInterface.logCAT('AGC bypassed', 'info');
        }
        
        // Add analyser
        if (this.analyser) {
            currentNode.connect(this.analyser);
            currentNode = this.analyser;
        }
        
        // Connect to output gain (speakers)
        if (this.gainNode) {
            currentNode.connect(this.gainNode);
        }

        this.isStreaming = true;
        const agcStatus = (this.agcEnabled && this.agcNode) ? ' (AGC Active)' : '';
        this.updateAudioStatus(`Audio Streaming - Live from QDX${agcStatus}`);
        this.updateAudioButtons();
        this.startAudioProcessingLoop();
        this.qdxInterface.logCAT('Audio streaming started successfully!', 'info');
        
    } catch (error) {
        this.qdxInterface.logCAT(`Audio start error: ${error.message}`, 'error');
        console.error('Full audio start error:', error);
    }
}




		
			updateAudioButtons() {
                const startBtn = document.getElementById('startAudioBtn');
                const stopBtn = document.getElementById('stopAudioBtn');
                if (this.isStreaming) {
                    startBtn.classList.replace('btn-primary', 'btn-secondary');
                    stopBtn.classList.replace('btn-secondary', 'btn-danger');
                } else {
                    startBtn.classList.replace('btn-secondary', 'btn-primary');
                    stopBtn.classList.replace('btn-danger', 'btn-secondary');
                }
            }
            
			
			setDspFilter(filterType) {
    if (!this.dspFilterNode) return;

    let centerFreq, bandwidth;

    switch (filterType) {
        case 'SSB_1800':
            centerFreq = 1500;
            bandwidth = 1800;
            break;
        case 'SSB_2400':
            centerFreq = 1500;
            bandwidth = 2400;
            break;
        case 'CW_500':
            centerFreq = 700; // A comfortable pitch for CW notes
            bandwidth = 500;
            break;
        case 'CW_250':
            centerFreq = 700;
            bandwidth = 250;
            break;
        case 'SSB_WIDE':
        default:
            centerFreq = 1700;
            bandwidth = 3200; // Wide open
            break;
    }

    this.dspFilterNode.frequency.setValueAtTime(centerFreq, this.audioContext.currentTime);
    // The Quality factor (Q) is defined as: centerFrequency / bandwidth
    const qFactor = centerFreq / bandwidth;
    this.dspFilterNode.Q.setValueAtTime(qFactor, this.audioContext.currentTime);

    this.qdxInterface.logCAT(`DSP filter set: ${bandwidth} Hz bandwidth`, 'info');
}


// Add these functions to QDXAudioProcessor class
setAgcEnabled(enabled) {
    this.agcEnabled = enabled;
    
    if (!this.isStreaming) {
        this.qdxInterface.logCAT(`AGC set to ${enabled ? 'enabled' : 'disabled'} (will apply on next start)`, 'info');
        return;
    }
    
    // Rebuild the audio chain if streaming
    try {
        // Disconnect everything
        if (this.inputGainNode) this.inputGainNode.disconnect();
        if (this.dspFilterNode) this.dspFilterNode.disconnect();
        if (this.agcNode) this.agcNode.disconnect();
        if (this.analyser) this.analyser.disconnect();
        
        // Rebuild chain
        let currentNode = this.inputGainNode || this.sourceNode;
        
        if (this.inputGainNode && this.sourceNode) {
            this.sourceNode.connect(this.inputGainNode);
            currentNode = this.inputGainNode;
        }
        
        if (this.dspFilterNode) {
            currentNode.connect(this.dspFilterNode);
            currentNode = this.dspFilterNode;
        }
        
        if (enabled && this.agcNode) {
            currentNode.connect(this.agcNode);
            currentNode = this.agcNode;
            this.qdxInterface.logCAT('AGC enabled - compression active', 'info');
        } else {
            this.qdxInterface.logCAT('AGC disabled - direct path', 'info');
        }
        
        if (this.analyser) {
            currentNode.connect(this.analyser);
            currentNode = this.analyser;
        }
        
        if (this.gainNode) {
            currentNode.connect(this.gainNode);
        }
        
    } catch (e) {
        this.qdxInterface.logCAT(`AGC toggle error: ${e.message}`, 'error');
        console.error('AGC toggle error:', e);
    }
}

setAgcThreshold(dB) {
    this.agcThreshold = dB;
    if (this.agcNode) {
        this.agcNode.threshold.value = dB;
        this.qdxInterface.logCAT(`AGC threshold: ${dB} dB`, 'info');
    }
}

setAgcRatio(ratio) {
    this.agcRatio = ratio;
    if (this.agcNode) {
        this.agcNode.ratio.value = ratio;
        this.qdxInterface.logCAT(`AGC ratio: ${ratio}:1`, 'info');
    }
}

setAgcSpeed(attack, release) {
    this.agcAttack = attack;
    this.agcRelease = release;
    if (this.agcNode) {
        this.agcNode.attack.value = attack;
        this.agcNode.release.value = release;
        this.qdxInterface.logCAT(`AGC speed: ${attack*1000}ms attack, ${release*1000}ms release`, 'info');
    }
}


			
			
            cleanup() {
                this.stopAudioStreaming();
                if (this.audioContext) {
                    this.audioContext.close();
                }
            }
        }
        
     
        class QDXInterface {
            constructor() {
                this.frequency = 14205000;
                this.stepSize = 100;
                this.mode = 'USB';
                this.connected = false;
                this.band = '20';
                this.currentVFO = 'A';
                this.transmitting = false;
                this.pollingInterval = null;
                
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.commandQueue = [];
                this.isProcessingQueue = false;
                this.catTimeout = null;
                this.connectionCheckTimeout = null;
                this.lastCommandTime = 0;
                
                this.memoryChannels = new Array(10).fill(null);
                this.selectedMemoryChannel = null;
                this.memoryMode = 'recall';
                this.isContinuousAutoTuneEnabled = false; // Tracks the toggle state
                this.isMouseOverTuningKnob = false;     // Tracks if mouse is over the dial
                this.autoTuneTimeout = null;  
                this.catLogElement = null;
                
                this.tuningKnobRotation = 0;
                this.tuningLastAngle = 0;
                this.isTuningAdjusting = false;
                this.tuningAnimationFrame = null;
                
                this.totalRotationRange = 270;
                this.minRotation = -135;
                this.maxRotation = 135;
                this.volumeKnobRotation = 0;
                this.volumeLevel = 75;
                this.volumeLastAngle = 0;
                this.isVolumeAdjusting = false;
                this.volumeAnimationFrame = null;
                this.volumeTimeout = null;
                
              /*  this.signalGenKnobRotation = 0;
                this.signalGenLevel = 50;
                this.signalGenLastAngle = 0;
                this.isSignalGenAdjusting = false;
                this.signalGenAnimationFrame = null;
                this.signalGenTimeout = null;*/

                this.nightModeEnabled = true; // Default to on

                this.lastFrequencies = {
                    '80': 3500000, '40': 7000000, '30': 10100000, '20': 14000000,
                    '17': 18068000, '15': 21000000, '12': 24890000, '10': 28000000
                };
                this.saveFreqTimeout = null;

                try {
                    this.catLogElement = document.getElementById('catLog');
                    
                    this.loadLayout();
                    this.loadLastFrequencies();
                    this.frequency = this.lastFrequencies[this.band];

                    this.initDraggablePanels();
                    this.initTuningKnob();
                    this.initEventListeners();
                    this.initVolumeControl();
                   // this.initSignalGenControl();
                    //this.initNightModeToggle();
                    this.initMemorySystem();
					this.initFrequencyKeypad();
                    this.updateDisplay();
                    this.updateTXStatus();
                    this.updateConnectionStatus();
                    this.initTimeSync();
                   
              
                    // Initialize audio processor with proper error handling
                    this.audioProcessor = new QDXAudioProcessor(this);
                     this.logCAT('Audio processor initialized', 'info');
                    
                    window.addEventListener('blur', () => {
                       // if (this.isSignalGenAdjusting) this.stopSignalGenAdjust();
                        if (this.isVolumeAdjusting) this.stopVolumeAdjust();
                        if (this.isTuningAdjusting) this.stopTuningAdjust();
                    });
                } catch (error) {
                    console.error('Failed to initialize QDX Interface:', error);
                }
            }
        
      

           initMemorySystem() {
    try {
        const savedMemories = localStorage.getItem('qdxMemoryChannels');
        if (savedMemories) {
            this.memoryChannels = JSON.parse(savedMemories);
        }
        
        // ✅ ADD: Null checks for all elements
        const storeBtn = document.getElementById('storeBtn');
        const recallBtn = document.getElementById('recallBtn');
        const editBtn = document.getElementById('editBtn');
        const clearBtn = document.getElementById('clearBtn');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const importFile = document.getElementById('importFile');
        
        if (!storeBtn || !recallBtn || !editBtn || !clearBtn) {
            console.error('Memory buttons not found in DOM');
            return;
        }
        
        storeBtn.addEventListener('click', () => this.setMemoryMode('store'));
        recallBtn.addEventListener('click', () => this.setMemoryMode('recall'));
        editBtn.addEventListener('click', () => this.setMemoryMode('edit'));
        clearBtn.addEventListener('click', () => this.setMemoryMode('clear'));
        
        if (exportBtn) exportBtn.addEventListener('click', () => this.exportMemories());
        if (importBtn) importBtn.addEventListener('click', () => {
            if (importFile) importFile.click();
        });
        if (clearAllBtn) clearAllBtn.addEventListener('click', () => this.clearAllMemories());
        if (importFile) importFile.addEventListener('change', (e) => this.importMemories(e));
        
        document.querySelectorAll('.memory-btn').forEach((btn) => {
            const channel = parseInt(btn.dataset.channel);
            let clickTimer = null;
            btn.addEventListener('click', (e) => {
                if (clickTimer) {
                    clearTimeout(clickTimer);
                    clickTimer = null;
                    if (this.memoryMode === 'recall') {
                        this.storeMemoryChannel(channel);
                        this.logCAT(`Quick-stored to M${channel}`, 'info');
                    }
                } else {
                    clickTimer = setTimeout(() => {
                        clickTimer = null;
                        this.handleMemoryChannel(channel);
                    }, 250);
                }
            });
            btn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                this.editMemoryChannel(channel);
            });
        });
        
        const saveMemoryEdit = document.getElementById('saveMemoryEdit');
        const cancelMemoryEdit = document.getElementById('cancelMemoryEdit');
        const modalOverlay = document.getElementById('modalOverlay');
        
        if (saveMemoryEdit) saveMemoryEdit.addEventListener('click', () => this.saveMemoryEdit());
        if (cancelMemoryEdit) cancelMemoryEdit.addEventListener('click', () => this.closeEditModal());
        if (modalOverlay) modalOverlay.addEventListener('click', () => this.closeEditModal());
        
        this.updateMemoryDisplay();
        this.setMemoryMode('recall');
        console.log('Memory system initialized');
    } catch (error) {
        console.error('Error initializing memory system:', error);
    }
}

            setMemoryMode(mode) {
                this.memoryMode = mode;
                const buttons = {
                    'store': document.getElementById('storeBtn'),
                    'recall': document.getElementById('recallBtn'),
                    'edit': document.getElementById('editBtn'),
                    'clear': document.getElementById('clearBtn')
                };
                Object.values(buttons).forEach(btn => {
                    btn.classList.remove('btn-primary', 'btn-danger');
                    btn.classList.add('btn-secondary');
                });
                if (buttons[mode]) {
                    buttons[mode].classList.remove('btn-secondary');
                    if (mode === 'clear') {
                        buttons[mode].classList.add('btn-danger');
                    } else {
                        buttons[mode].classList.add('btn-primary');
                    }
                }
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    btn.classList.remove('memory-store-warning');
                    btn.style.cursor = mode === 'recall' ? 'pointer' : 
                                      mode === 'store' ? 'copy' :
                                      mode === 'edit' ? 'text' :
                                      mode === 'clear' ? 'not-allowed' : 'pointer';
                    if (mode === 'store' && this.memoryChannels[index]) {
                        btn.classList.add('memory-store-warning');
                    }
                });
                this.logCAT(`Memory mode: ${mode.toUpperCase()} (${this.getMemoryModeHint(mode)})`, 'info');
            }

            getMemoryModeHint(mode) {
                switch(mode) {
                    case 'recall': return 'Click to recall, double-click to quick-store, right-click to edit';
                    case 'store': return 'Click any memory to store current settings';
                    case 'edit': return 'Click any memory to edit its settings';
                    case 'clear': return 'Click any memory to clear it';
                    default: return '';
                }
            }

            handleMemoryChannel(channel) {
                switch(this.memoryMode) {
                    case 'store': this.storeMemoryChannel(channel); break;
                    case 'recall': this.recallMemoryChannel(channel); break;
                    case 'edit': this.editMemoryChannel(channel); break;
                    case 'clear': this.clearMemoryChannel(channel); break;
                }
            }

            storeMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const existingLabel = this.memoryChannels[channelIndex]?.label || '';
                if (this.memoryChannels[channelIndex]) {
                    const existingMem = this.memoryChannels[channelIndex];
                    const freqMHz = (existingMem.frequency / 1000000).toFixed(3);
                    const label = existingMem.label ? `"${existingMem.label}"` : '';
                    if (!confirm(`Overwrite M${channel}?\n\nCurrent: ${freqMHz} MHz, ${existingMem.mode}${label}\n\nReplace with: ${(this.frequency / 1000000).toFixed(3)} MHz, ${this.mode}?`)) {
                        return;
                    }
                }
                const memoryData = {
                    frequency: this.frequency,
                    mode: this.mode,
                    band: this.band,
                    label: existingLabel,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = channel;
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Stored M${channel}: ${mhz}.${khz}.${hz} Hz, ${this.mode}${existingLabel ? ', "' + existingLabel + '"' : ''}`, 'info');
                setTimeout(() => {
                    this.setMemoryMode('recall');
                }, 1000);
            }

            recallMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                if (!memoryData) {
                    this.logCAT(`Memory M${channel} is empty`, 'error');
                    return;
                }
                this.frequency = memoryData.frequency;
                this.mode = memoryData.mode;
                this.band = memoryData.band;
                this.updateDisplay();
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === this.mode) {
                        btn.classList.add('active');
                    }
                });
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.band === this.band) {
                        btn.classList.add('active');
                    }
                });
                if (this.connected) {
                    const freqStr = this.frequency.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
                        setTimeout(() => {
                            this.sendCommand(this.getVFOCommand());
                        }, 100);
                    }).catch(e => {
                        this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
                    });
                    
                    const modeBtn = document.querySelector(`[data-mode="${this.mode}"]`);
                    if (modeBtn) {
                        const catMode = modeBtn.dataset.catmode;
                        this.sendCommand(`MD${catMode}`).catch(e => {
                            console.error("Mode command error:", e);
                        });
                    }
                }
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                const label = memoryData.label ? ` "${memoryData.label}"` : '';
                this.logCAT(`Recalled M${channel}${label}: ${mhz}.${khz}.${hz} Hz, ${this.mode}`, 'info');
                this.selectedMemoryChannel = channel;
                this.updateMemoryDisplay();
            }

            editMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                this.editingChannel = channel;
                document.getElementById('modalOverlay').classList.add('active');
                document.getElementById('memoryEditModal').classList.add('active');
                document.getElementById('editChannelNumber').textContent = channel;
                const freqInput = document.getElementById('memoryFreqInput');
                const modeSelect = document.getElementById('memoryModeSelect');
                const bandSelect = document.getElementById('memoryBandSelect');
                const labelInput = document.getElementById('memoryLabelInput');
                if (memoryData) {
                    freqInput.value = (memoryData.frequency / 1000000).toFixed(6);
                    modeSelect.value = memoryData.mode;
                    bandSelect.value = memoryData.band;
                    labelInput.value = memoryData.label || '';
                } else {
                    freqInput.value = (this.frequency / 1000000).toFixed(6);
                    modeSelect.value = this.mode;
                    bandSelect.value = this.band;
                    labelInput.value = '';
                }
                freqInput.addEventListener('input', () => {
                    const freqMHz = parseFloat(freqInput.value);
                    if (!isNaN(freqMHz)) {
                        const suggestedBand = this.getBandFromFrequency(freqMHz);
                        if (suggestedBand) {
                            bandSelect.value = suggestedBand;
                        }
                    }
                });
                freqInput.focus();
                freqInput.select();
                const handleEnter = (e) => {
                    if (e.key === 'Enter') {
                        this.saveMemoryEdit();
                    } else if (e.key === 'Escape') {
                        this.closeEditModal();
                    }
                };
                freqInput.onkeydown = handleEnter;
                labelInput.onkeydown = handleEnter;
            }

            saveMemoryEdit() {
                if (this.editingChannel === null) return;
                const channelIndex = this.editingChannel - 1;
                const freqInput = document.getElementById('memoryFreqInput').value.trim();
                const mode = document.getElementById('memoryModeSelect').value;
                const band = document.getElementById('memoryBandSelect').value;
                const label = document.getElementById('memoryLabelInput').value.trim();
                let frequency;
                if (freqInput) {
                    const cleanFreq = freqInput.replace(/[^0-9.]/g, '');
                    const freqMHz = parseFloat(cleanFreq);
                    if (isNaN(freqMHz) || freqMHz < 0.1 || freqMHz > 999.999999) {
                        alert('Please enter a valid frequency');
                        document.getElementById('memoryFreqInput').focus();
                        return;
                    }
                    frequency = Math.round(freqMHz * 1000000);
                } else {
                    alert('Please enter a frequency');
                    document.getElementById('memoryFreqInput').focus();
                    return;
                }
                const memoryData = {
                    frequency: frequency,
                    mode: mode,
                    band: band,
                    label: label,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = this.editingChannel;
                const freqStr = frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Updated M${this.editingChannel}: ${mhz}.${khz}.${hz} Hz, ${mode}, ${band}m${label ? ', "' + label + '"' : ''}`, 'info');
                this.closeEditModal();
            }

            closeEditModal() {
                document.getElementById('modalOverlay').classList.remove('active');
                document.getElementById('memoryEditModal').classList.remove('active');
                this.editingChannel = null;
            }






            clearMemoryChannel(channel) {
                const channelIndex = channel - 1;
                if (this.memoryChannels[channelIndex]) {
                    const memData = this.memoryChannels[channelIndex];
                    const freqMHz = (memData.frequency / 1000000).toFixed(3);
                    const label = memData.label || `M${channel}`;
                    if (confirm(`Clear memory channel M${channel}?\n\nFrequency: ${freqMHz} MHz\nMode: ${memData.mode}\nLabel: ${label}`)) {
                        this.memoryChannels[channelIndex] = null;
                        localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                        this.updateMemoryDisplay();
                        this.logCAT(`Cleared memory channel M${channel}`, 'info');
                        if (this.selectedMemoryChannel === channel) {
                            this.selectedMemoryChannel = null;
                        }
                    }
                } else {
                    this.logCAT(`Memory M${channel} is already empty`, 'error');
                }
            }

            clearAllMemories() {
                const usedMemories = this.memoryChannels.filter(m => m !== null).length;
                if (usedMemories === 0) {
                    this.logCAT('No memory channels to clear', 'info');
                    return;
                }
                if (confirm(`Clear ALL memory channels?\n\nThis will delete ${usedMemories} stored memories.\nThis action cannot be undone!`)) {
                    this.memoryChannels = new Array(10).fill(null);
                    localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                    this.selectedMemoryChannel = null;
                    this.updateMemoryDisplay();
                    this.logCAT(`Cleared all ${usedMemories} memory channels`, 'info');
                }
            }

            updateMemoryDisplay() {
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    const channel = index + 1;
                    const memoryData = this.memoryChannels[index];
                    btn.innerHTML = '';
                    btn.classList.remove('memory-occupied', 'memory-selected', 'memory-store-warning');
                    if (memoryData) {
                        btn.classList.add('memory-occupied');
                        if (this.memoryMode === 'store') {
                            btn.classList.add('memory-store-warning');
                        }
                        const channelSpan = document.createElement('span');
                        channelSpan.textContent = `M${channel}`;
                        btn.appendChild(channelSpan);
                        if (memoryData.label) {
                            const labelSpan = document.createElement('span');
                            labelSpan.className = 'memory-label';
                            labelSpan.textContent = memoryData.label;
                            btn.appendChild(labelSpan);
                        }
                        btn.title = `M${channel}: ${(memoryData.frequency / 1000000).toFixed(3)} MHz, ${memoryData.mode}${memoryData.label ? ' - ' + memoryData.label : ''}`;
                    } else {
                        btn.textContent = `M${channel}`;
                        btn.title = `M${channel}: Empty`;
                    }
                    if (this.selectedMemoryChannel === channel) {
                        btn.classList.add('memory-selected');
                    }
                });
            }

            exportMemories() {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    memories: this.memoryChannels
                };
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qdx_memories_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('Memory channels exported successfully', 'info');
            }

            importMemories(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        if (importData.memories && Array.isArray(importData.memories)) {
                            if (confirm('This will replace all current memory channels. Continue?')) {
                                this.memoryChannels = importData.memories;
                                localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                                this.updateMemoryDisplay();
                                this.logCAT('Memory channels imported successfully', 'info');
                            }
                        } else {
                            throw new Error('Invalid file format');
                        }
                    } catch (error) {
                        this.logCAT(`Import failed: ${error.message}`, 'error');
                        alert('Failed to import memory file.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }


            logCAT(message, type = 'info') {
                if (!this.catLogElement) {
                    this.catLogElement = document.getElementById('catLog');
                }
                if (!this.catLogElement) return;
                const entry = document.createElement('div');
                entry.className = `cat-log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `${timestamp} ${type.toUpperCase()}: ${message}`;
                this.catLogElement.appendChild(entry);
                this.catLogElement.scrollTop = this.catLogElement.scrollHeight;
                while (this.catLogElement.children.length > 200) {
                    this.catLogElement.removeChild(this.catLogElement.firstChild);
                }
            }

            async initializeRadio() {
                await this.sendCommand('IF');
                await this.sendCommand('FA');
                await this.sendCommand('MD');
                await this.sendCommand('AG');
                await this.sendCommand('ID');
                await this.sendNightModeCommand();
            }

  initEventListeners() {
    // Serial Connection
    document.getElementById('connectBtn').addEventListener('click', () => this.connected ? this.disconnectSerial() : this.connectSerial());

    // Audio Panel
    document.getElementById('startAudioBtn').addEventListener('click', () => this.audioProcessor.startAudioStreaming());
    document.getElementById('stopAudioBtn').addEventListener('click', () => this.audioProcessor.stopAudioStreaming());
  //  document.getElementById('testAudioBtn').addEventListener('click', () => this.audioProcessor.testAudioSystem());
    document.getElementById('sampleRate').addEventListener('change', (e) => this.audioProcessor.sampleRate = parseInt(e.target.value));
	document.getElementById('nightModeToggle').addEventListener('click', () => this.toggleNightMode());
    document.getElementById('fftSize').addEventListener('change', (e) => {
        if (this.audioProcessor.analyser) {
            this.audioProcessor.analyser.fftSize = parseInt(e.target.value);
        }
    });
  document.getElementById('audioVolumeSlider').addEventListener('input', (e) => {
    // Allow up to 200% gain (2x amplification)
    const gainMultiplier = 3.0;
    this.audioProcessor.audioVolume = (e.target.value / 100) * gainMultiplier;
    document.getElementById('audioVolumeLevel').textContent = `${e.target.value}%`;
    if (this.audioProcessor.gainNode) {
        this.audioProcessor.gainNode.gain.value = this.audioProcessor.audioVolume;
    }
});
    document.getElementById('waterfallSpeed').addEventListener('input', (e) => this.audioProcessor.waterfallSpeed = parseInt(e.target.value));
    
    const outputDeviceSelect = document.getElementById('audioOutputDevice');
    if (outputDeviceSelect) {
        outputDeviceSelect.addEventListener('change', (e) => {
            const selectedText = e.target.options[e.target.selectedIndex].text;
            this.logCAT(`Setting audio output to: ${selectedText}`, 'info');
            this.audioProcessor.setAudioOutput(e.target.value);
        });
    }
    
    // Auto Tune Controls
    document.getElementById('autoTuneNowBtn').addEventListener('click', () => this.performAutoTune());
    document.getElementById('continuousAutoTuneToggle').addEventListener('click', () => this.toggleContinuousAutoTune());

    // Mode, Band, Step
    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.mode = btn.dataset.mode;
            if (this.connected) {
                const catMode = btn.dataset.catmode;
                this.sendCommand(`MD${catMode}`);
                this.logCAT(`Mode changed to ${this.mode}`, 'info');
            }
        });
    });
    document.querySelectorAll('.band-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.band = btn.dataset.band;
            this.setBandFrequency(btn.dataset.band);
        });
    });
    document.getElementById('stepSize').addEventListener('change', (e) => {
        this.stepSize = parseInt(e.target.value);
        this.logCAT(`Tuning step set to ${this.stepSize} Hz`, 'info');
    });

    // VFO and Transmit
    document.getElementById('vfoA').addEventListener('click', () => this.selectVFO('A'));
    document.getElementById('vfoB').addEventListener('click', () => this.selectVFO('B'));
  
	
	 // ADD THIS LISTENER for the new DSP dropdown
    document.getElementById('dspFilterSelect').addEventListener('change', (e) => {
        if (this.audioProcessor) {
            this.audioProcessor.setDspFilter(e.target.value);
        }
    });
	
	
// --- END OF BLOCK ---
	
	// Add to initEventListeners() function

// AGC Toggle
const agcToggle = document.getElementById('agcToggle');
if (agcToggle) {
    agcToggle.classList.add('active'); // Start enabled
    agcToggle.addEventListener('click', () => {
        const enabled = !agcToggle.classList.contains('active');
        if (enabled) {
            agcToggle.classList.add('active');
        } else {
            agcToggle.classList.remove('active');
        }
        this.audioProcessor.setAgcEnabled(enabled);
    });
}

// AGC Preset
// Update this event listener in initEventListeners()

document.getElementById('agcPreset').addEventListener('change', (e) => {
    const preset = e.target.value;
    let ratio, threshold, knee;
    
    switch(preset) {
        case 'weak':
            ratio = 4;
            threshold = -18;
            knee = 20;
            break;
        case 'strong':
            ratio = 20;
            threshold = -35; // CHANGED: Lower threshold
            knee = 40;      // CHANGED: Wider knee
            break;
        case 'medium':
        default:
            ratio = 12;
            threshold = -30; // CHANGED: Lower threshold
            knee = 30;       // CHANGED: Wider knee
            break;
    }
    
    this.audioProcessor.setAgcThreshold(threshold);
    this.audioProcessor.setAgcRatio(ratio);
    if (this.audioProcessor.agcNode) {
        this.audioProcessor.agcNode.knee.value = knee;
    }
    this.logCAT(`AGC preset: ${preset} (${ratio}:1, ${threshold}dB, ${knee}dB knee)`, 'info');
});




	
	
	
	
}
            setBandFrequency(band) {
                if (this.lastFrequencies[band]) {
                    this.frequency = this.lastFrequencies[band];
                    this.updateDisplay();
                    if (this.connected) {
                        this.sendFrequencyImmediate();
                    }
                }
            }

            getBandFromFrequency(freqMHz) {
                if (freqMHz >= 3.500 && freqMHz <= 4.000) return '80';
                if (freqMHz >= 7.000 && freqMHz <= 7.300) return '40';
                if (freqMHz >= 10.100 && freqMHz <= 10.150) return '30';
                if (freqMHz >= 14.000 && freqMHz <= 14.350) return '20';
                if (freqMHz >= 18.068 && freqMHz <= 18.168) return '17';
                if (freqMHz >= 21.000 && freqMHz <= 21.450) return '15';
                if (freqMHz >= 24.890 && freqMHz <= 24.990) return '12';
                if (freqMHz >= 28.000 && freqMHz <= 29.700) return '10';
                return null;
            }
            
            selectVFO(vfo) {
                this.currentVFO = vfo;
                this.updateVFOButtons();
                this.logCAT(`VFO ${vfo} selected`, 'info');
            }

            updateConnectionStatus() {
                const btn = document.getElementById('connectBtn');
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const baudDropdown = document.getElementById('baudRate');
                if (this.connected) {
                    btn.textContent = 'Disconnect';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-danger');
                    statusDot.classList.add('connected');
                    statusText.textContent = 'CONNECTED';
                    statusText.className = 'status-text connected';
                    baudDropdown.disabled = true;
                } else {
                    btn.textContent = 'Connect Serial';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-primary');
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'DISCONNECTED';
                    statusText.className = 'status-text disconnected';
                    baudDropdown.disabled = false;
                }
				this.updateTXStatus();
            }

 updateTXStatus() {
    
}

            updateModeFromCAT(catMode) {
                const modeMap = {
                    '1': 'LSB', '2': 'USB'
                };
                if (modeMap[catMode]) {
                    this.mode = modeMap[catMode];
                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.mode === this.mode) {
                            btn.classList.add('active');
                        }
                    });
                } else {
                    this.logCAT(`Unknown mode code received: ${catMode}`, 'error');
                }
            }

          setTransmitState(isTransmitting) {
    if (this.connected) {
        const command = isTransmitting ? 'TX' : 'RX';
        this.sendCommand(command);
        this.transmitting = isTransmitting;
        this.updateTXStatus();
        this.logCAT(`Switched to ${isTransmitting ? 'TRANSMIT' : 'RECEIVE'} mode`, 'info');
    } else if (isTransmitting) {
        this.logCAT('Cannot transmit - radio not connected', 'error');
    }
}

            updateLcdDisplay(row1, row2) {
                const lcdRow1El = document.getElementById('lcdRow1');
                const lcdRow2El = document.getElementById('lcdRow2');
                
                if (lcdRow1El) {
                    lcdRow1El.textContent = row1;
                }
                if (lcdRow2El) {
                    lcdRow2El.textContent = row2;
                }
                
                const detectedVFO = (row1 && row1.charAt(0) === 'B') ? 'B' : 'A';
                
                if (detectedVFO !== this.currentVFO) {
                    this.currentVFO = detectedVFO;
                    this.updateVFOButtons();
                    this.logCAT(`VFO switched to ${this.currentVFO} (auto-detected)`, 'info');
                }
            }

            updateDisplay() {
                this.updateBandFromFrequency();
                const freqMHz = (this.frequency / 1000000).toFixed(6);
                this.updateLcdDisplay(`${this.currentVFO}: ${freqMHz} MHz`, `${this.mode} ${this.band}m`);
            }

            updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('currentTime').textContent = timeString;
                setTimeout(() => this.updateClock(), 1000);
            }

            async initTimeSync() {
                this.updateClock();
            }

            updateBandFromFrequency() {
                const freqMHz = this.frequency / 1000000;
                const detectedBand = this.getBandFromFrequency(freqMHz);
                
                if (detectedBand && detectedBand !== this.band) {
                    this.band = detectedBand;
                    this.updateBandButtons();
                    this.logCAT(`Auto-selected ${this.band}m band for ${freqMHz.toFixed(3)} MHz`, 'info');
                }
            }

            updateBandButtons() {
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.band === this.band) {
                        btn.classList.add('active');
                    }
                });
            } 

            updateVFOButtons() {
                document.querySelectorAll('#vfoA, #vfoB').forEach(btn => {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                });
                
                const activeButton = document.getElementById(`vfo${this.currentVFO}`);
                if (activeButton) {
                    activeButton.classList.remove('btn-secondary');
                    activeButton.classList.add('btn-primary');
                }
            }

            getVFOCommand() {
                return this.currentVFO === 'B' ? 'FB' : 'FA';
            }

            loadLastFrequencies() {
                const savedFrequencies = localStorage.getItem('qdxLastFrequencies');
                if (savedFrequencies) {
                    try {
                        const parsedFrequencies = JSON.parse(savedFrequencies);
                        this.lastFrequencies = { ...this.lastFrequencies, ...parsedFrequencies };
                        console.log('Loaded last-used frequencies.');
                    } catch(e) {
                        console.error('Could not parse saved frequencies, using defaults.');
                    }
                }
            }
            
            saveLastFrequency() {
                if (this.saveFreqTimeout) {
                    clearTimeout(this.saveFreqTimeout);
                }
                this.saveFreqTimeout = setTimeout(() => {
                    this.lastFrequencies[this.band] = this.frequency;
                    localStorage.setItem('qdxLastFrequencies', JSON.stringify(this.lastFrequencies));
                }, 1000);
            }
            
            initDraggablePanels() {
                try {
                    const leftPanel = document.querySelector('.left-panel');
                    const centerPanel = document.querySelector('.center-panel');
                    const rightPanel = document.querySelector('.right-panel');

                    const options = {
                        group: 'shared-panels',
                        handle: 'h3',
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        dragClass: 'sortable-drag',
                        onEnd: () => {
                            this.saveLayout();
                        }
                    };

                    Sortable.create(leftPanel, options);
                    Sortable.create(centerPanel, options);
                    Sortable.create(rightPanel, options);
                } catch(e) {
                    console.warn("Could not initialize draggable panels. Is Sortable.js loaded?");
                }
            }

            saveLayout() {
                const layout = {
                    left: [...document.querySelectorAll('.left-panel .panel')].map(p => p.id),
                    center: [...document.querySelectorAll('.center-panel .panel')].map(p => p.id),
                    right: [...document.querySelectorAll('.right-panel .panel')].map(p => p.id)
                };
                localStorage.setItem('qdxPanelLayout', JSON.stringify(layout));
                this.logCAT('Panel layout saved.', 'info');
            }

            loadLayout() {
                const savedLayout = localStorage.getItem('qdxPanelLayout');
                if (savedLayout) {
                    try {
                        const layout = JSON.parse(savedLayout);
                        const columns = {
                            left: document.querySelector('.left-panel'),
                            center: document.querySelector('.center-panel'),
                            right: document.querySelector('.right-panel')
                        };

                        Object.keys(layout).forEach(columnKey => {
                            layout[columnKey].forEach(panelId => {
                                const panelElement = document.getElementById(panelId);
                                if (panelElement && columns[columnKey]) {
                                    columns[columnKey].appendChild(panelElement);
                                }
                            });
                        });
                        console.log('Custom panel layout loaded.');
                    } catch (e) {
                        console.error("Failed to load custom layout, using default.", e);
                        localStorage.removeItem('qdxPanelLayout');
                    }
                }
            }

            initVolumeControl() {
                try {
                    const volumeKnob = document.getElementById('volumeKnob');
                    this.updateVolumeUI();
                    volumeKnob.addEventListener('mousedown', this.startVolumeAdjust.bind(this));
                    volumeKnob.addEventListener('touchstart', this.startVolumeAdjust.bind(this), { passive: false });
                    volumeKnob.addEventListener('wheel', this.handleVolumeWheel.bind(this));
                    volumeKnob.addEventListener('keydown', this.handleVolumeKeyboard.bind(this));
                    console.log('Volume control initialized');
                } catch (error) {
                    console.error('Error initializing volume control:', error);
                }
            }

            startVolumeAdjust(e) {
                e.preventDefault();
                this.isVolumeAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueVolumeAdjust = this.continueVolumeAdjust.bind(this);
                this.boundStopVolumeAdjust = this.stopVolumeAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.volumeLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.addEventListener('mouseup', this.boundStopVolumeAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.volumeLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueVolumeAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopVolumeAdjust);
                }
            }

            continueVolumeAdjust(e) {
                if (!this.isVolumeAdjusting) return;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    const volumeKnob = document.getElementById('volumeKnob');
                    const rect = volumeKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.volumeLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 1.2;
                    deltaAngle *= sensitivity;
                    const newRotation = this.volumeKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.volumeKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    volumeKnob.style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                    const newVolumeLevel = Math.round(((this.volumeKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                    if (newVolumeLevel !== this.volumeLevel) {
                        this.volumeLevel = newVolumeLevel;
                        this.updateVolumeUI();
                        this.sendVolumeDynamically();
                    }
                    this.volumeLastAngle = currentAngle;
                    this.volumeAnimationFrame = null;
                });
            }

            stopVolumeAdjust() {
                this.isVolumeAdjusting = false;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                    this.volumeAnimationFrame = null;
                }
                if (this.boundContinueVolumeAdjust && this.boundStopVolumeAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('mouseup', this.boundStopVolumeAdjust);
                    document.removeEventListener('touchmove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('touchend', this.boundStopVolumeAdjust);
                    this.boundContinueVolumeAdjust = null;
                    this.boundStopVolumeAdjust = null;
                }
                this.sendVolumeCommand();
            }

            handleVolumeKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustVolume(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustVolume(5);
                }
            }

            handleVolumeWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const volumeDelta = steps * 5;
                this.adjustVolume(volumeDelta);
            }

            adjustVolume(delta) {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel + delta));
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    this.updateVolumeUI();
                    this.sendVolumeCommand();
                    this.volumeAnimationFrame = null;
                });
            }
			
            updateVolumeUI() {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel));
                this.volumeKnobRotation = this.minRotation + (this.volumeLevel / 100) * this.totalRotationRange;
                document.getElementById('volumeKnob').style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                document.getElementById('volumeLevel').textContent = `${this.volumeLevel}%`;
                document.getElementById('volumeKnob').setAttribute('aria-valuenow', this.volumeLevel);
            }

            sendVolumeDynamically() {
                if (this.volumeTimeout) {
                    clearTimeout(this.volumeTimeout);
                }
                this.volumeTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        this.sendCommand(`AG${this.volumeLevel.toString().padStart(3, '0')}`).catch(e => {
                            console.error("Volume update error:", e);
                        });
                    }
                    this.volumeTimeout = null;
                }, 50);
            }

            async sendVolumeCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    await this.sendCommand(`AG${this.volumeLevel.toString().padStart(3, '0')}`);
                    this.logCAT(`AF Gain set to ${this.volumeLevel}%`, 'info');
                } catch (e) {
                    this.logCAT(`AF Gain command error: ${e.message}`, 'error');
                }
            }

           /* initSignalGenControl() {
                try {
                    const signalGenKnob = document.getElementById('signalGenKnob');
                    this.signalGenKnobRotation = this.minRotation + (this.signalGenLevel / 100) * this.totalRotationRange;
                    signalGenKnob.style.transform = `rotate(${this.signalGenKnobRotation}deg)`;
                    
                    this.updateSignalGenLevel();
                    
                    signalGenKnob.addEventListener('mousedown', this.startSignalGenAdjust.bind(this));
                    signalGenKnob.addEventListener('touchstart', this.startSignalGenAdjust.bind(this), { passive: false });
                    signalGenKnob.addEventListener('wheel', this.handleSignalGenWheel.bind(this));
                    signalGenKnob.addEventListener('keydown', this.handleSignalGenKeyboard.bind(this));
                    signalGenKnob.setAttribute('aria-valuenow', this.signalGenLevel);
                    
                    console.log('Signal Generator control initialized');
                } catch (error) {
                    console.error('Error initializing Signal Generator control:', error);
                }
            }

            startSignalGenAdjust(e) {
                e.preventDefault();
                this.isSignalGenAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueSignalGenAdjust = this.continueSignalGenAdjust.bind(this);
                this.boundStopSignalGenAdjust = this.stopSignalGenAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.signalGenLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueSignalGenAdjust);
                    document.addEventListener('mouseup', this.boundStopSignalGenAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.signalGenLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueSignalGenAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopSignalGenAdjust);
                }
            }

            continueSignalGenAdjust(e) {
                if (!this.isSignalGenAdjusting) return;
                if (this.signalGenAnimationFrame) {
                    cancelAnimationFrame(this.signalGenAnimationFrame);
                }
                this.signalGenAnimationFrame = requestAnimationFrame(() => {
                    const signalGenKnob = document.getElementById('signalGenKnob');
                    const rect = signalGenKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.signalGenLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 0.7;
                    deltaAngle *= sensitivity;
                    const newRotation = this.signalGenKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.signalGenKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    signalGenKnob.style.transform = `rotate(${this.signalGenKnobRotation}deg)`;
                    const newSignalGenLevel = Math.round(((this.signalGenKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                    if (newSignalGenLevel !== this.signalGenLevel) {
                        this.signalGenLevel = newSignalGenLevel;
                        this.updateSignalGenLevel();
                        this.sendSignalGenDynamically();
                    }
                    this.signalGenLastAngle = currentAngle;
                    this.signalGenAnimationFrame = null;
                });
            }

            stopSignalGenAdjust() {
                this.isSignalGenAdjusting = false;
                if (this.signalGenAnimationFrame) {
                    cancelAnimationFrame(this.signalGenAnimationFrame);
                    this.signalGenAnimationFrame = null;
                }
                if (this.boundContinueSignalGenAdjust && this.boundStopSignalGenAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueSignalGenAdjust);
                    document.removeEventListener('mouseup', this.boundStopSignalGenAdjust);
                    document.removeEventListener('touchmove', this.boundContinueSignalGenAdjust);
                    document.removeEventListener('touchend', this.boundStopSignalGenAdjust);
                    this.boundContinueSignalGenAdjust = null;
                    this.boundStopSignalGenAdjust = null;
                }
                this.sendSignalGenCommand();
            }

            handleSignalGenKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustSignalGen(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustSignalGen(5);
                }
            }

            handleSignalGenWheel(e) {
                e.preventDefault();
                let steps = e.deltaY > 0 ? -1 : 1;
                const signalGenDelta = steps * 5;
                this.adjustSignalGen(signalGenDelta);
            }

            adjustSignalGen(delta) {
                this.signalGenLevel = Math.max(0, Math.min(100, this.signalGenLevel + delta));
                this.signalGenKnobRotation = this.minRotation + (this.signalGenLevel / 100) * this.totalRotationRange;
                if (this.signalGenAnimationFrame) {
                    cancelAnimationFrame(this.signalGenAnimationFrame);
                }
                this.signalGenAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('signalGenKnob').style.transform = `rotate(${this.signalGenKnobRotation}deg)`;
                    this.updateSignalGenLevel();
                    this.sendSignalGenCommand();
                    this.signalGenAnimationFrame = null;
                });
            }

            updateSignalGenLevel() {
                // Convert percentage to frequency (500Hz to 2000Hz range)
                const frequency = 500 + (this.signalGenLevel / 100) * 1500;
                document.getElementById('signalGenLevel').textContent = `${(frequency/1000).toFixed(1)}kHz`;
                document.getElementById('signalGenKnob').setAttribute('aria-valuenow', this.signalGenLevel);
            }

            sendSignalGenDynamically() {
                if (this.signalGenTimeout) {
                    clearTimeout(this.signalGenTimeout);
                }
                this.signalGenTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const frequency = Math.round(500 + (this.signalGenLevel / 100) * 1500);
                        this.sendCommand(`C2${frequency.toString().padStart(8, '0')}`).catch(e => {
                            console.error("Signal Gen update error:", e);
                        });
                    }
                    this.signalGenTimeout = null;
                }, 50);
            }

            async sendSignalGenCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const frequency = Math.round(500 + (this.signalGenLevel / 100) * 1500);
                    await this.sendCommand(`C2${frequency.toString().padStart(8, '0')}`);
                    this.logCAT(`Signal Generator set to ${(frequency/1000).toFixed(1)}kHz`, 'info');
                } catch (e) {
                    this.logCAT(`Signal Generator command error: ${e.message}`, 'error');
                }
            }
*/
            initNightModeToggle() {
                try {
                    const nightModeToggle = document.getElementById('nightModeToggle');
                    
                    // Set initial state
                    this.updateNightModeUI();
                    
                    // Add click event listener
                    nightModeToggle.addEventListener('click', () => {
                        this.toggleNightMode();
                    });
                    
                    console.log('Night Mode toggle initialized');
                } catch (error) {
                    console.error('Error initializing Night Mode toggle:', error);
                }
            }

          /*  toggleNightMode() {
                this.nightModeEnabled = !this.nightModeEnabled;
                this.updateNightModeUI();
                this.sendNightModeCommand();
            }*/
updateNightModeUI() {
    const toggle = document.getElementById('nightModeToggle');
    // The 'status' element does not exist, so we remove references to it.
    
    if (this.nightModeEnabled) {
        toggle.classList.add('active');
    } else {
        toggle.classList.remove('active');
    }
}

            async sendNightModeCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const command = this.nightModeEnabled ? 'QI1' : 'QI0';
                    await this.sendCommand(command);
                    this.logCAT(`Night Mode ${this.nightModeEnabled ? 'enabled' : 'disabled'}`, 'info');
                } catch (e) {
                    this.logCAT(`Night Mode command error: ${e.message}`, 'error');
                }
            }

            initTuningKnob() {
                try {
                    const tuningKnob = document.getElementById('tuningKnob');
                    
					// Add these two event listeners
tuningKnobContainer.addEventListener('mouseenter', () => {
    this.isMouseOverTuningKnob = true;
});
tuningKnobContainer.addEventListener('mouseleave', () => {
    this.isMouseOverTuningKnob = false;
});
					this.createFrequencyMarkings();
                    this.tuningKnobRotation = 0;
                    tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    
                    tuningKnob.addEventListener('mousedown', this.startTuningAdjust.bind(this));
                    tuningKnob.addEventListener('touchstart', this.startTuningAdjust.bind(this), { passive: false });
                    tuningKnob.addEventListener('wheel', this.handleTuningWheel.bind(this));
                    tuningKnob.addEventListener('keydown', this.handleTuningKeyboard.bind(this));
                    
                    // Add hover keyboard control
                    this.isHoveringTuningKnob = false;
                    this.boundHandleHoverKeyboard = this.handleHoverKeyboard.bind(this);
                    
                    tuningKnob.addEventListener('mouseenter', () => {
                        this.isHoveringTuningKnob = true;
                        tuningKnob.style.boxShadow = '0 0 20px rgba(255, 107, 53, 0.6), 0 12px 24px rgba(0, 0, 0, 0.4)';
                        document.addEventListener('keydown', this.boundHandleHoverKeyboard);
                        this.logCAT('Tuning knob hover: Use arrow keys to tune', 'info');
                    });
                    
                    tuningKnob.addEventListener('mouseleave', () => {
                        this.isHoveringTuningKnob = false;
                        tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3)';
                        document.removeEventListener('keydown', this.boundHandleHoverKeyboard);
                    });
                    
                    tuningKnob.setAttribute('aria-valuenow', this.frequency);
                    console.log('Tuning knob initialized with hover keyboard control');
                } catch (error) {
                    console.error('Error initializing tuning knob:', error);
                }
            }

            handleHoverKeyboard(e) {
                if (!this.isHoveringTuningKnob) return;
                
                // Prevent default behavior for arrow keys
                if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                    e.preventDefault();
                    
                    let freqDelta = 0;
                    const currentStep = this.stepSize;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'ArrowDown':
                            freqDelta = -currentStep;
                            break;
                        case 'ArrowRight':
                        case 'ArrowUp':
                            freqDelta = currentStep;
                            break;
                    }
                    
                    if (freqDelta !== 0) {
                        // Use larger steps if Shift is held
                        if (e.shiftKey) {
                            freqDelta *= 10;
                        }
                        
                        // Use even larger steps if Ctrl is held
                        if (e.ctrlKey) {
                            freqDelta *= 100;
                        }
                        
                        this.updateFrequency(freqDelta);
                        
                        // Update knob rotation
                        const rotationDelta = (freqDelta / currentStep) * 2;
                        this.tuningKnobRotation += rotationDelta;
                        document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                        
                        // Send frequency immediately
                        this.sendFrequencyImmediate();
                        
                        // Show feedback
                        const stepText = e.shiftKey ? `${currentStep * 10} Hz` : 
                                        e.ctrlKey ? `${currentStep * 100} Hz` : 
                                        `${currentStep} Hz`;
                        this.logCAT(`Keyboard tune: ${freqDelta > 0 ? '+' : ''}${freqDelta} Hz (${stepText} step)`, 'info');
                    }
                }
            }

            createFrequencyMarkings() {
                const markingsContainer = document.getElementById('frequencyMarkings');
                markingsContainer.innerHTML = '';
                for (let i = 0; i < 72; i++) {
                    const angle = (i / 72) * 360;
                    const isLarge = i % 6 === 0;
                    const mark = document.createElement('div');
                    mark.className = `frequency-mark ${isLarge ? 'major' : 'minor'}`;
                    mark.style.transform = `rotate(${angle}deg) translate(0, -140px)`;
                    mark.style.left = '50%';
                    mark.style.top = '50%';
                    mark.style.marginLeft = isLarge ? '-1.5px' : '-0.5px';
                    mark.style.marginTop = isLarge ? '-10px' : '-5px';
                    markingsContainer.appendChild(mark);
                }
            }

            startTuningAdjust(e) {
                e.preventDefault();
                this.isTuningAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueTuningAdjust = this.continueTuningAdjust.bind(this);
                this.boundStopTuningAdjust = this.stopTuningAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.tuningLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.addEventListener('mouseup', this.boundStopTuningAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.tuningLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueTuningAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopTuningAdjust);
                }
            }

            continueTuningAdjust(e) {
                if (!this.isTuningAdjusting) return;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    const tuningKnob = document.getElementById('tuningKnob');
                    const rect = tuningKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    
                    const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
                    if (distance < rect.width * 2) {
                        const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                        let deltaAngle = currentAngle - this.tuningLastAngle;
                        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                        
                        const sensitivity = 1.5;
                        deltaAngle *= sensitivity;
                        this.tuningKnobRotation += (deltaAngle * 180 / Math.PI);
                        tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                        
                        const freqDelta = (deltaAngle * 180 / Math.PI) * this.stepSize * 0.3;
                        
                        if (Math.abs(freqDelta) > 0.1) {
                            this.updateFrequency(freqDelta);
                            this.sendFrequencyImmediate();
                        }
                        this.tuningLastAngle = currentAngle;
                    }
                    this.tuningAnimationFrame = null;
                });
            }

            stopTuningAdjust() {
                this.isTuningAdjusting = false;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                    this.tuningAnimationFrame = null;
                }
                if (this.boundContinueTuningAdjust && this.boundStopTuningAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.removeEventListener('mouseup', this.boundStopTuningAdjust);
                    document.removeEventListener('touchmove', this.boundContinueTuningAdjust);
                    document.removeEventListener('touchend', this.boundStopTuningAdjust);
                    this.boundContinueTuningAdjust = null;
                    this.boundStopTuningAdjust = null;
                }
                this.sendFrequencyImmediate();
				 if (this.isContinuousAutoTuneEnabled && this.isMouseOverTuningKnob) {
        if (this.autoTuneTimeout) clearTimeout(this.autoTuneTimeout);
        
        this.logCAT('Stopped tuning. Auto-tune scheduled...', 'info');
        this.autoTuneTimeout = setTimeout(() => {
            this.performAutoTune(true); // Pass 'true' to indicate it's an automatic call
        }, 500); // 500ms delay
    }
            }

            handleTuningWheel(e) {
                e.preventDefault();
                
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                
                const freqDelta = steps * this.stepSize;
                
                this.updateFrequency(freqDelta);
                const rotationDelta = steps * 2;
                this.tuningKnobRotation += rotationDelta;
                document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                this.sendFrequencyDynamically();
            }

            handleTuningKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustFrequency(-this.stepSize);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustFrequency(this.stepSize);
                }
            }

            adjustFrequency(delta) {
                this.updateFrequency(delta);
                const rotationDelta = (delta / this.stepSize) * 2;
                this.tuningKnobRotation += rotationDelta;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    this.sendFrequencyImmediate();
                    this.tuningAnimationFrame = null;
                });
            }

            sendFrequencyImmediate() {
                if (this.connected && this.port && this.writer) {
                    const freqStr = this.frequency.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    this.sendCommand(`${vfoCommand}${freqStr}`).catch(e => {
                        console.error("Frequency update error:", e);
                    });
                }
            }

            sendFrequencyDynamically() {
                if (this.catTimeout) {
                    clearTimeout(this.catTimeout);
                }
                this.catTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const freqStr = this.frequency.toString().padStart(11, '0');
                        const vfoCommand = this.getVFOCommand();
                        this.sendCommand(`${vfoCommand}${freqStr}`).catch(e => {
                            console.error("Frequency update error:", e);
                        });
                    }
                    this.catTimeout = null;
                }, 5);
            }
			
            startPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                this.pollingInterval = setInterval(async () => {
                    if (this.connected) {
                        await this.sendCommand('IF');
                        await this.sendCommand('AG');
                        await this.sendCommand('QI');
						await this.sendCommand('VN');
						  // TEST: Animate meters with fake data
           
						
                    }
                }, 500);
            }

            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                }
            }

            parseIfResponse(data) {
                try {
                    const freq = parseInt(data.substring(0, 11));
                    if (!isNaN(freq) && freq > 0 && freq !== this.frequency && !this.isTuningAdjusting) {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                    const txStatus = data.substring(26, 27);
                    const isTransmitting = (txStatus === '1');
                    if (isTransmitting !== this.transmitting) {
                        this.transmitting = isTransmitting;
                        this.updateTXStatus();
                    }
                    const catMode = data.substring(27, 28);
                    this.updateModeFromCAT(catMode);
                } catch (error) {
                    this.logCAT(`Error parsing IF response: ${error.message}`, 'error');
                }
            }

            async sendFrequencyCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const freqStr = this.frequency.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    await this.sendCommand(`${vfoCommand}${freqStr}`);
                    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    const displayStr = this.frequency.toString().padStart(9, '0');
                    const mhz = displayStr.substring(0, 3);
                    const khz = displayStr.substring(3, 6); 
                    const hz = displayStr.substring(6, 9);
                    this.logCAT(`VFO ${this.currentVFO} frequency set to ${mhz}.${khz}.${hz} Hz`, 'info');
                } catch (e) {
                    this.logCAT(`Frequency command error: ${e.message}`, 'error');
                }
            }

            async updateFrequency(delta) {
                this.frequency += delta;
                this.frequency = Math.max(100000, Math.min(999999999, this.frequency));
                this.frequency = Math.round(this.frequency);
                this.updateDisplay();
                this.saveLastFrequency();
            }

            async connectSerial() {
                try {
                    if (!navigator.serial) {
                        this.logCAT('WebSerial API not supported', 'error');
                        return false;
                    }

                    const selectedBaud = parseInt(document.getElementById('baudRate').value);
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ 
                        baudRate: selectedBaud,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none',
                        flowControl: 'none'
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    
                    this.connected = true;
                    this.lastCommandTime = Date.now();
                    this.updateConnectionStatus();
                    this.logCAT(`Serial connected at ${selectedBaud} baud`, 'rx');
                    
                    this.startReading();
                    this.startConnectionHealthCheck();
                    await this.initializeRadio();
                    this.startPolling();
                    return true;
                } catch (error) {
                    this.logCAT(`Connection failed: ${error.message}`, 'error');
                    this.connected = false;
                    this.updateConnectionStatus();
                    return false;
                }
            }

            async disconnectSerial() {
                try {
                    this.connected = false;
                    
                    // Stop audio streaming if active
                    if (this.audioProcessor && this.audioProcessor.isStreaming) {
                        await this.audioProcessor.stopAudioStreaming();
                    }
                    
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.stopPolling();
                    if (this.reader) {
                        try {
                            await this.reader.cancel();
                        } catch (e) {
                            console.log('Reader cancel error:', e);
                        }
                        try {
                            await this.reader.releaseLock();
                        } catch (e) {
                            console.log('Reader release error:', e);
                        }
                        this.reader = null;
                    }
                    if (this.writer) {
                        try {
                            await this.writer.releaseLock();
                        } catch (e) {
                            console.log('Writer release error:', e);
                        }
                        this.writer = null;
                    }
                    if (this.port) {
                        try {
                            await this.port.close();
                        } catch (e) {
                            console.log('Port close error:', e);
                        }
                        this.port = null;
                    }
                    this.logCAT('Serial disconnected', 'rx');
                } catch (error) {
                    this.connected = false;
                    this.reader = null;
                    this.writer = null;
                    this.port = null;
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.logCAT(`Disconnect error: ${error.message}`, 'rx');
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.connected && this.reader) {
                        try {
                            const { value, done } = await this.reader.read();
                            if (done) {
                                this.logCAT('Hardware disconnected', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            }
                            const text = new TextDecoder().decode(value);
                            buffer += text;
                            this.lastCommandTime = Date.now();
                            while (buffer.includes(';')) {
                                const end = buffer.indexOf(';');
                                const response = buffer.substring(0, end);
                                buffer = buffer.substring(end + 1);
                                if (response.trim()) {
                                    this.processResponse(response.trim());
                                }
                            }
                        } catch (readError) {
                            if (readError.name === 'NetworkError' || 
                                readError.message.includes('device has been lost') ||
                                readError.message.includes('The port is not open') ||
                                readError.code === 19) {
                                this.logCAT('Hardware disconnected during read', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            } else {
                                this.logCAT(`Read error: ${readError.message}`, 'error');
                            }
                        }
                    }
                } catch (error) {
                    this.logCAT(`Reader stream error: ${error.message}`, 'error');
                    if (this.connected) {
                        this.handleHardwareDisconnect();
                    }
                }
            }

            async sendCommand(command) {
                if (!this.connected || !this.writer) {
                    return null;
                }
                try {
                    const fullCommand = command + ';';
                    const data = new TextEncoder().encode(fullCommand);
                    await this.writer.write(data);
                    this.logCAT(command, 'tx');
                    this.lastCommandTime = Date.now();
                    return true;
                } catch (error) {
                    if (error.name === 'NetworkError' || 
                        error.message.includes('device has been lost') ||
                        error.message.includes('The port is not open') ||
                        error.code === 19) {
                        this.logCAT('Hardware disconnected during command', 'error');
                        this.handleHardwareDisconnect();
                    } else {
                        this.logCAT(`Send error: ${error.message}`, 'error');
                    }
                    return false;
                }
            }

            handleHardwareDisconnect() {
                if (!this.connected) return;
                this.connected = false;
                this.reader = null;
                this.writer = null;
                this.port = null;
                if (this.connectionCheckTimeout) {
                    clearTimeout(this.connectionCheckTimeout);
                    this.connectionCheckTimeout = null;
                }
                this.updateConnectionStatus();
                this.logCAT('Auto-disconnect complete', 'rx');
            }

            startConnectionHealthCheck() {
                if (!this.connected) return;
                const now = Date.now();
                const timeSinceLastCommand = now - this.lastCommandTime;
                if (timeSinceLastCommand > 10000 && this.connected) {
                    this.sendCommand('ID').catch(() => {
                        this.logCAT('Connection health check failed', 'error');
                        this.handleHardwareDisconnect();
                    });
                }
                this.connectionCheckTimeout = setTimeout(() => {
                    this.startConnectionHealthCheck();
                }, 5000);
            }

            processResponse(response) {
                this.logCAT(response, 'rx');
                if (response.startsWith('IF')) {
                    this.parseIfResponse(response.substring(2));
                } else if (response.startsWith('AG')) {
                    const gain = parseInt(response.substring(2));
                    if (!isNaN(gain) && !this.isVolumeAdjusting) {
                        this.volumeLevel = gain;
                        this.updateVolumeUI();
                    }
                } else if (response.startsWith('FA')) {
                    const freq = parseInt(response.substring(2));
                    if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'A') {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                } else if (response.startsWith('FB')) {
                    const freq = parseInt(response.substring(2));
                    if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'B') {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                } else if (response.startsWith('MD')) {
                    const mode = response.substring(2);
                    this.updateModeFromCAT(mode);
                } else if (response.startsWith('TX')) {
                    this.transmitting = true;
                    this.updateTXStatus();
                } else if (response.startsWith('RX')) {
                    this.transmitting = false;
                    this.updateTXStatus();
                } else if (response.startsWith('ID')) {
                    this.logCAT(`Radio ID: ${response.substring(2)}`, 'info');
            /*    } else if (response.startsWith('C2')) {
                    const freq = parseInt(response.substring(2));
                    if (!isNaN(freq) && !this.isSignalGenAdjusting) {
                        const percentage = ((freq - 500) / 1500) * 100;
                        this.signalGenLevel = Math.max(0, Math.min(100, percentage));
                        this.updateSignalGenLevel();
                    } */
                } else if (response.startsWith('QI')) {
                    const nightMode = response.substring(2);
                    if (nightMode === '1' || nightMode === '0') {
                        this.nightModeEnabled = (nightMode === '1');
                        this.updateNightModeUI();
                    }
                }
            }



initFrequencyKeypad() {
    const lcdPanel = document.getElementById('lcdPanel');
    const keypadModal = document.getElementById('frequencyKeypadModal');
    const modalOverlay = document.getElementById('modalOverlay');
    const keypadCancel = document.getElementById('keypadCancel');
    const keypadEnter = document.getElementById('keypadEnter');

    if (!lcdPanel || !keypadModal) {
        console.error('Frequency keypad elements not found');
        return;
    }

    lcdPanel.style.cursor = 'pointer';
    lcdPanel.addEventListener('click', (e) => {
        e.stopPropagation();
        this.openFrequencyKeypad();
    });

    // Keypad button handlers
    document.querySelectorAll('.keypad-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const value = btn.dataset.value;
            const action = btn.dataset.action;

            if (action === 'backspace') this.keypadBackspace();
            else if (action === 'clear') this.keypadClear();
            else if (value) this.keypadInput(value);
        });
    });

    keypadCancel.addEventListener('click', (e) => { e.stopPropagation(); this.closeFrequencyKeypad(); });
    keypadEnter.addEventListener('click', (e) => { e.stopPropagation(); this.submitFrequencyKeypad(); });
    keypadModal.addEventListener('click', (e) => e.stopPropagation());

    // Keyboard support
    this.keypadKeyHandler = (e) => {
        if (!keypadModal.classList.contains('active')) return;
        
        if (e.key >= '0' && e.key <= '9') this.keypadInput(e.key);
        else if (e.key === '.') this.keypadInput('.');
        else if (e.key === 'Backspace') this.keypadBackspace();
        else if (e.key === 'Enter') this.submitFrequencyKeypad();
        else if (e.key === 'Escape') this.closeFrequencyKeypad();
        else if (e.key.toLowerCase() === 'c') this.keypadClear(); // Add clear shortcut
    };
    
    document.addEventListener('keydown', this.keypadKeyHandler);
    console.log('Frequency keypad initialized');
}

openFrequencyKeypad() {
    const keypadModal = document.getElementById('frequencyKeypadModal');
    const modalOverlay = document.getElementById('modalOverlay');
    
    this.keypadClear(); // Start with a clean slate
    
    modalOverlay.classList.add('active');
    keypadModal.classList.add('active');
    this.logCAT('Frequency keypad opened', 'info');
}

closeFrequencyKeypad() {
    const keypadModal = document.getElementById('frequencyKeypadModal');
    const modalOverlay = document.getElementById('modalOverlay');
    keypadModal.classList.remove('active');
    if (!document.getElementById('memoryEditModal').classList.contains('active')) {
        modalOverlay.classList.remove('active');
    }
}

keypadInput(value) {
    const keypadDisplay = document.getElementById('keypadDisplay');
    let current = keypadDisplay.textContent;
    if (value === '.' && current.includes('.')) return;
    if (current.length >= 12) return;
    keypadDisplay.textContent = current + value;
}

keypadBackspace() {
    const keypadDisplay = document.getElementById('keypadDisplay');
    let current = keypadDisplay.textContent;
    if (current.length > 0) {
        keypadDisplay.textContent = current.slice(0, -1);
    }
}

// NEW FUNCTION
keypadClear() {
    const keypadDisplay = document.getElementById('keypadDisplay');
    keypadDisplay.textContent = '';
}

// UPDATED FUNCTION with intelligent parsing
submitFrequencyKeypad() {
    const keypadDisplay = document.getElementById('keypadDisplay');
    const input = keypadDisplay.textContent.trim();
    
    if (!input) {
        alert('Please enter a frequency.');
        return;
    }

    let freqHz = 0;

    // Check if input is likely kHz (no decimal) or MHz (has decimal)
    if (input.includes('.')) {
        // User entered MHz, e.g., "14.205" or "3.7"
        // parseFloat handles cases like "14.133.456" by stopping at the second dot, resulting in 14.133
        const freqMHz = parseFloat(input);
        if (isNaN(freqMHz)) {
            alert('Invalid frequency format.');
            return;
        }
        freqHz = Math.round(freqMHz * 1000000);
    } else {
        // User likely entered kHz, e.g., "7074" or "14205"
        const freqKHz = parseInt(input, 10);
        if (isNaN(freqKHz)) {
            alert('Invalid frequency format.');
            return;
        }
        freqHz = freqKHz * 1000;
    }
    
    // Validate the final frequency is within a reasonable range
    if (freqHz < 100000 || freqHz > 1000000000) { // 100 kHz to 1 GHz
        alert(`Frequency out of range. Please enter a valid frequency.`);
        return;
    }
    
    // Update frequency and UI
    this.frequency = freqHz;
    this.updateDisplay();
    
    // Send to radio if connected
    if (this.connected) {
        this.sendFrequencyImmediate();
    }
    
    this.logCAT(`Frequency set via keypad: ${(freqHz / 1000000).toFixed(6)} MHz`, 'info');
    this.closeFrequencyKeypad();
}







openFrequencyKeypad() {
    const keypadModal = document.getElementById('frequencyKeypadModal');
    const modalOverlay = document.getElementById('modalOverlay');
    const keypadDisplay = document.getElementById('keypadDisplay');
    
    // Set current frequency
    const freqMHz = (this.frequency / 1000000).toFixed(6);
    keypadDisplay.textContent = freqMHz;
    
    modalOverlay.classList.add('active');
    keypadModal.classList.add('active');
    this.logCAT('Frequency keypad opened', 'info');
}

closeFrequencyKeypad() {
    const keypadModal = document.getElementById('frequencyKeypadModal');
    const modalOverlay = document.getElementById('modalOverlay');
    
    keypadModal.classList.remove('active');
    // Only close overlay if memory modal is also closed
    if (!document.getElementById('memoryEditModal').classList.contains('active')) {
        modalOverlay.classList.remove('active');
    }
}

keypadInput(value) {
    const keypadDisplay = document.getElementById('keypadDisplay');
    let current = keypadDisplay.textContent;
    
    // Don't allow multiple decimal points
    if (value === '.' && current.includes('.')) {
        return;
    }
    
    // Limit length
    if (current.length >= 12) {
        return;
    }
    
    keypadDisplay.textContent = current + value;
}

keypadBackspace() {
    const keypadDisplay = document.getElementById('keypadDisplay');
    let current = keypadDisplay.textContent;
    
    if (current.length > 0) {
        keypadDisplay.textContent = current.slice(0, -1);
    }
}

submitFrequencyKeypad() {
    const keypadDisplay = document.getElementById('keypadDisplay');
    const input = keypadDisplay.textContent.trim();
    
    if (!input) {
        alert('Please enter a frequency');
        return;
    }
    
    const freqMHz = parseFloat(input);
    
    if (isNaN(freqMHz) || freqMHz < 0.1 || freqMHz > 999.999999) {
        alert('Invalid frequency. Please enter a value between 0.1 and 999.999999 MHz');
        return;
    }
    
    // Convert to Hz
    const freqHz = Math.round(freqMHz * 1000000);
    
    // Update frequency
    this.frequency = freqHz;
    this.updateDisplay();
    
    // Send to radio if connected
    if (this.connected) {
        this.sendFrequencyImmediate();
    }
    
    this.logCAT(`Frequency set via keypad: ${(freqHz / 1000000).toFixed(6)} MHz`, 'info');
    this.closeFrequencyKeypad();
}
async performAutoTune(isAutomatic = false) {
    const btn = document.getElementById('autoTuneNowBtn');

    // Prerequisite Checks
    if (!this.connected) {
        if (!isAutomatic) this.logCAT('Auto-tune failed: Radio not connected.', 'error');
        return;
    }
    
    if (!this.audioProcessor || !this.audioProcessor.isStreaming) {
        if (!isAutomatic) this.logCAT('Auto-tune failed: Start RX audio first.', 'error');
        return;
    }
    
    if (!this.audioProcessor.analyser) {
        if (!isAutomatic) this.logCAT('Auto-tune failed: Analyser not available.', 'error');
        return;
    }

    if (!isAutomatic) {
        btn.textContent = 'Analyzing...';
        btn.disabled = true;
    }

    try {
        const analyser = this.audioProcessor.analyser;
        const sampleRate = this.audioProcessor.sampleRate;
        const fftSize = analyser.fftSize;
        
        // Use multiple samples for better accuracy
        const numSamples = 5;
        const allFreqData = [];
        
        for (let s = 0; s < numSamples; s++) {
            const freqData = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(freqData);
            allFreqData.push(freqData);
            await new Promise(resolve => setTimeout(resolve, 20)); // 20ms between samples
        }
        
        // Average the samples to reduce noise
        const avgFreqData = new Uint8Array(analyser.frequencyBinCount);
        for (let i = 0; i < avgFreqData.length; i++) {
            let sum = 0;
            for (let s = 0; s < numSamples; s++) {
                sum += allFreqData[s][i];
            }
            avgFreqData[i] = sum / numSamples;
        }
        
        const freqPerBin = sampleRate / fftSize;
        
        // Voice frequency range
        const minSearchFreq = 300;
        const maxSearchFreq = 3000;
        const targetAudioFreq = 1500;
        
        const minBin = Math.floor(minSearchFreq / freqPerBin);
        const maxBin = Math.ceil(maxSearchFreq / freqPerBin);
        
        // Calculate noise floor (average of lowest 10% of bins)
        const sortedData = [...avgFreqData].sort((a, b) => a - b);
        const noiseFloorSamples = Math.floor(sortedData.length * 0.1);
        let noiseFloor = 0;
        for (let i = 0; i < noiseFloorSamples; i++) {
            noiseFloor += sortedData[i];
        }
        noiseFloor = noiseFloor / noiseFloorSamples;
        
        // Signal must be significantly above noise floor
        const signalThreshold = noiseFloor + 30; // 30 units above noise
        
        // Find peaks
        const peaks = [];
        for (let i = minBin + 1; i < maxBin - 1; i++) {
            const current = avgFreqData[i];
            const prev = avgFreqData[i - 1];
            const next = avgFreqData[i + 1];
            
            // Peak detection: current bin higher than neighbors
            if (current > prev && current > next && current > signalThreshold) {
                peaks.push({
                    bin: i,
                    frequency: i * freqPerBin,
                    power: current
                });
            }
        }
        
        if (peaks.length === 0) {
            if (!isAutomatic) {
                this.logCAT(`Auto-tune: No clear signal detected. Noise floor: ${noiseFloor.toFixed(0)}`, 'error');
            }
            return;
        }
        
        // Sort peaks by power
        peaks.sort((a, b) => b.power - a.power);
        
        // Use the strongest peak
        const strongestPeak = peaks[0];
        
        // Refine peak frequency using parabolic interpolation
        const y1 = avgFreqData[strongestPeak.bin - 1];
        const y2 = strongestPeak.power;
        const y3 = avgFreqData[strongestPeak.bin + 1];
        
        const delta = 0.5 * (y1 - y3) / (y1 - 2*y2 + y3);
        const refinedBin = strongestPeak.bin + delta;
        const refinedFreq = refinedBin * freqPerBin;
        
        const offset = refinedFreq - targetAudioFreq;
        
        // Sanity checks
        if (Math.abs(offset) > 1200) {
            if (!isAutomatic) {
                this.logCAT(`Auto-tune: Offset too large (${offset.toFixed(0)} Hz). Manual tuning recommended.`, 'error');
            }
            return;
        }
        
        if (Math.abs(offset) < 15) {
            if (!isAutomatic) {
                this.logCAT(`Auto-tune: Already tuned! Signal at ${refinedFreq.toFixed(0)} Hz (offset: ${offset.toFixed(0)} Hz)`, 'info');
            }
            return;
        }
        
        // Calculate SNR
        const snr = strongestPeak.power - noiseFloor;
        
        if (snr < 20) {
            if (!isAutomatic) {
                this.logCAT(`Auto-tune: Signal too weak (SNR: ${snr.toFixed(1)} dB). Increase volume or tune closer.`, 'error');
            }
            return;
        }
        
        // Apply VFO adjustment
        const finalAdjustment = this.mode === 'USB' ? -offset : offset;
        
        this.logCAT(`Auto-tune: Peak at ${refinedFreq.toFixed(0)} Hz (SNR: ${snr.toFixed(1)} dB). Adjusting ${finalAdjustment.toFixed(0)} Hz`, 'info');
        
        // Show all detected peaks for debugging
        if (!isAutomatic && peaks.length > 1) {
            const otherPeaks = peaks.slice(1, 4).map(p => `${p.frequency.toFixed(0)}Hz`).join(', ');
            this.logCAT(`Other signals detected: ${otherPeaks}`, 'info');
        }
        
        this.updateFrequency(finalAdjustment);
        this.sendFrequencyImmediate();
        
    } catch (error) {
        this.logCAT(`Auto-tune error: ${error.message}`, 'error');
        console.error('Auto-tune error:', error);
    } finally {
        if (!isAutomatic) {
            setTimeout(() => {
                btn.textContent = 'AutoTune Now';
                btn.disabled = false;
            }, 1000);
        }
    }
}




toggleContinuousAutoTune() {
    this.isContinuousAutoTuneEnabled = !this.isContinuousAutoTuneEnabled;
    const toggle = document.getElementById('continuousAutoTuneToggle');
    const status = document.getElementById('continuousAutoTuneStatus');

    if (this.isContinuousAutoTuneEnabled) {
        toggle.classList.add('active');
        status.textContent = 'ENABLED';
        status.style.color = '#ff6b35';
        this.logCAT('Continuous Auto-Tune ENABLED.', 'info');
    } else {
        toggle.classList.remove('active');
        status.textContent = 'DISABLED';
        status.style.color = '#fff';
        this.logCAT('Continuous Auto-Tune DISABLED.', 'info');
    }
}
initNightModeToggle() {
    // 1. Load the saved state from storage
    const savedState = localStorage.getItem('qdxNightMode');
    if (savedState !== null) {
        this.nightModeEnabled = JSON.parse(savedState);
    }

    // 2. Set the initial UI based on the loaded state
    this.updateNightModeUI();

    // 3. Listen for clicks on the new toggle
    document.getElementById('nightModeToggle').addEventListener('click', () => {
        this.toggleNightMode();
    });
    
    console.log(`Night Mode initialized to: ${this.nightModeEnabled ? 'ENABLED' : 'DISABLED'}`);
}

toggleNightMode() {
    // Flip the state
    this.nightModeEnabled = !this.nightModeEnabled;

    // Save the new state to storage
    localStorage.setItem('qdxNightMode', this.nightModeEnabled);
    this.logCAT(`Night Mode ${this.nightModeEnabled ? 'enabled' : 'disabled'}`, 'info');

    // Update the UI
    this.updateNightModeUI();
    
    // ADD THIS LINE to send the command to the radio
    this.sendNightModeCommand();
}
updateNightModeUI() {
    const body = document.body;
    const toggle = document.getElementById('nightModeToggle');
    const status = document.getElementById('nightModeStatus');

    if (this.nightModeEnabled) {
        body.classList.add('night-mode-active');
        toggle.classList.add('active');
        status.textContent = 'ENABLED';
        status.style.color = '#ff6b35';
    } else {
        body.classList.remove('night-mode-active');
        toggle.classList.remove('active');
        status.textContent = 'DISABLED';
        status.style.color = '#fff';
    }
}

            cleanup() {
                if (this.pollingInterval) clearInterval(this.pollingInterval);
                if (this.connectionCheckTimeout) clearTimeout(this.connectionCheckTimeout);
                if (this.audioProcessor) {
                    this.audioProcessor.cleanup();
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                new QDXInterface();
            } catch (error) {
                console.error('Failed to initialize QDX Interface:', error);
            }
        });
    </script>

</html>